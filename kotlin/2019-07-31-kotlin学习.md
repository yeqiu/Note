---
layout:     post  
title:      kotlin学习 
subtitle:   kotlin
date:       2019-07-31
author:     小卷子
header-img: 这篇文章标题背景图片
catalog: true
tags:
    - 标签
---









[TOC]







##数据类型

### string的比较,== 和equals()

java比较字符串的内存地址用==，kotlin用===

kotlin中的== 和equals()是完全相同的

~~~java
s1 == s2;//相当于java中的equals()
s1 === s2;//相当于java中的==
~~~



### 字符串模板

可以在代码中声明一个变量，在变量前用$修饰，就变成了直接引用该对象。

~~~kotlin
val a = 10
val s = "a = $a" //打印结果为a = 10

val s = "Hello World"
println("s.length=${s.length}")
~~~



### var和val区别

**var：** var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。
**val:** val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。



### 转义字符

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5j0063p8oj30fs09l0t4.jpg)





### ”“”三个引号

使用三个引号(""")包括，内部没有转义，可以包含换行和任何其他文本。所有转义在三个引号中都会失效





### 类和对象

java中创建类

~~~java
				public class Animal {
  
		    private int age;
 		  	private boolean sex;
        private String name;

        public Animal(int age, boolean sex, String name) {
            this.age = age;
            this.sex = sex;
            this.name = name;
      		  }
    		}
~~~

创建一个cat继承Animal

```
				public class Cat extends Animal {

 				   public Cat(int age, boolean sex, String name) {
 				       super(age, sex, name);
				    }

				    public void eat(){
				        System.out.println("猫 调用eat()");
				    }
    
				}
```

在使用上

~~~java
   		 public static void main(String[] args) {
   		     Animal animal = new Cat(1,true,"cat");
   		     if (animal instanceof Cat){
 		           Cat cat= (Cat) animal;
 		           cat.eat();
		        }
		    }
~~~



这是一段很简单的java代码，创建了Animal类，又创建Cat继承Animal，Cat中新加了eat()方法，main()中创建了一个Cat并赋值给了Animal，这里是父类引用指向子类对象。然后又把Animal强转成Cat并调用eat()方法。



以下是kotlin的实现方式

~~~java
				//kotli中所有类默认都是final,可以用open解除
				//constructor是构造方法
				//创建对象时默认执行
				open class Person constructor(var name: String, var age: Int, var sex: String) {

				    init {
				        println("姓名：$name,年龄：$age,性别：$sex")
				    }
				}
~~~



~~~java
				class Coder(name: String, age: Int, sex: String) : Person(name, age, sex) {
 
 				   fun coding() {
 				       println("coding")
 				   }
				}
~~~

~~~java
				fun main(args: Array<String>) {

				    var person: Person = Coder("Android", 18, "男");
				    //相当于java的强转，如果转换失败会抛出异常
				    val coder = person as Coder
				    coder.coding()
				}
~~~





### null安全



~~~java
				public String getName(){
     		   if (true){
       		     return "name";
      		  }else{
      		      return null;
      		  }
    		}
~~~

这是一段很常见的java代码，getName返回一个string，但是也可能会返回null。所有在调用的时候一般都会做*Nullcheck*

~~~java
				fun getName():String{
  				  if (true){
 				       return "name"
				    }else{
				        return null
 				   }
				}
~~~

以上是getName() kotlin的写法，但是这么写在编辑器中会报错。因为方法返回一个string不能返回null，修改为

~~~java
				fun getName(): String? {
				    if (true){
        				return "name"
    				}else{
        				return null
				    }
				}
~~~

这时候编译就没问题了，但是和java的写法一样都会有null的问题。看看这种写法在用的时候会有什么不一样

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6kvsv0sj30jy0h9dfy.jpg)

这里定义了两个getName()，第一个可能会返回null，第二个不会返回null。在main方法中调用。可以看到第一个在`println(name.length)`的时候报错了。错误如下图;

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6mfx9y6j30hh01ujr8.jpg)

大概的意思就是name这个值可能会是null，用的时候要做判断。改成这样

~~~java
				fun main() {
 				   val name = getName()
 				   val name2 = getName2()
 				   if (name!=null){
  				      println(name.length)
 				   }
 				   println(name2.length)
 				   //if中的判断也可以简化成，意思就是如果name不是null就正常执行否则直接输出null
 				    println(name?.length)
      
				}
~~~



还有场景

~~~java
				String name = getName();
        if (name==null){
            return;
        }
~~~

这段也是很常见的，如果name是null直接返回，不在执行下面的代码。kontlin中也可以这么写，但是写完之后编辑器会提示你可以简化成这样

~~~java
				//如果name是null直接return
				val name = getName() ?: return;
~~~

再看这段代码

![原谅我的分号](http://ww3.sinaimg.cn/large/006tNc79ly1g5k6ynshhkj30f1056jr9.jpg)



这里没有对name字段做任何非null的判断，但是在println中并没有报错，因为上一句代码中已经说明如果name是null的话就return(原谅我的分号)



另一种情况

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k7dm1e85j30ah02imwz.jpg)

这里声明了一个可以为null的name，那在调用的时候编译器又会提示*Nullcheck*，但是我知道这里的name不是null，可以换成下面的写法

~~~java
				fun main() {
				    var name:String? = "aaa";
				    println(name!!.length)
				}
~~~

在变量前用!!表示对象非null，如果name真的是null的话同样也会抛出NullPointerException，开发中不要这么干，这是很危险的，

~~~java
 		   //任何的对象都可能存在null的情况
 		  	 val notNull: String = null;//编译器报错，notNull对象不能为null
 		  	 val nullable: String? = null;//正确，String?表示可以为null
 		   	notNull.length //正确，notNull对象不可能为null可以直接使用
  		  nullable.length //编译器报错，nullable对象可能为null必须先做Nullcheck
  		  nullable!!.length //正确 开发者确认nullable不为null，但是仍有空指针风险，这是很危险的操作
  		  nullable?.length //正确 如果nullable是null直接会返回null并不调用length方法
~~~



最后总结一下，其实在实际开发中null是不可避免的。在ava的编辑器感觉不够重视NullPointerException,我刚工作的时候被null折磨的苦不堪言，甚至改过IDE生成get()的模板来自动生成非null对象。kotlin中同样无法避免null，但是开发时编辑器会自动提示null的安全判断，同时也简化了null的判断（写法上我还是感觉有点怪）,编译器也变得十分智能。其实这并不能叫null安全，只是编辑器强制开发者必须要做*Nullcheck*。





### 类型转换

java中的强转

~~~java
        //创建cat并赋值给animal
        Animal animal = new Cat(1,true,"小猫咪");
        //调用cat中eat方法,必须先进行强转
        if (animal instanceof Cat){
            //强转成cat
            ((Cat) animal).eat();
        }
~~~

kotlin

```java
		var person :Person = Coder("Android",18,"男");
		//is 相当于java中的 instanceof
		if (person is Coder){
		    person.coding()
		}
```

可以看到都需要做强转前的判断，但是kotlin在判断后就不需要在做强转的操作。if成立后编译器认为`person == Coder`

另一个场景

```java
		//这里java会直接报类型转换异常
		Animal animal = new Animal(1,true,"小猫咪");
		((Cat) animal).eat();
```

kotlin

~~~java
		var person: Person = Person("Android", 18, "男");
		(person as Coder).coding()
~~~

这里强转同样会异常，看另一种写法

```java
		//这里在强转的时候使用了as？表示如果强转失败将会等到null，那在调用coding方法的时候判断为null停止调用
		var person: Person = Person("Android", 18, "男");
		val coder: Coder? = person as? Coder
		coder?.coding()
```



### 关于？和！！

**"?"加在变量名后，系统在任何情况不会报它的空指针异常。**
**"!!"加在变量名后，如果对象为null，那么系统一定会报异常！**

**?**到底怎么用。
在声明对象时，把它跟在类名后面，表示这个类允许为null；
在调用对象时，把它跟在对象后面，表示如果为null程序直接返回null并不继续调用

~~~kotlin
    var coder: Coder? = null
    //如果coder == null,coding方法不会执行
    coder?.coding()
    //如果coder == null并不影响这句代码
    println(coder === null)
~~~



然而加上问号以后程序就万事大吉永远摆脱了NullPointerException的烦恼？我们再看下一段代码：

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9jaus0kj30fh03g746.jpg)

报错信息

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9kas1w2j30mj01cdfo.jpg)

大概的意思是 list?.size > 0可能会返回null，null无法跟int进行比较，建议改成`list?.size!! > 0` 

好，一旦改成了这样这里的list就是null那运行到list?.size必然会空指针。看来必须要加上if !=null的判断，

~~~java
    		if (list!=null){
     		    if (list?.size > 0){
     		       println("list的长度不是0")
     		   } 
   		 }
~~~

然后这样就和java一样，有些啰嗦。可以简化成下面这样

```java
				if (list?.size ?: 0 > 0) {
				    println("list的长度不是0")
				}
```

Kotlin提供了`对象A ?: 对象B`表达式，并且取消了Java中的`条件表达式 ? 表达式1 : 表达式2`这个三元表达式。

?:表示的意思是，当对象A值为null的时候，那么它就会返回后面的对象B。

拆开来看上面的代码 list?.size ?: 0 > 0

```java
				val list: ArrayList<String>? = null
				val size = list?.size ?: 0//仅仅在左边的表达式结果为空时才会计算?:后面的表达式
				if (size > 0) {
  				  println("list的长度不是0")
				}
```



关于?:

这个也不是Java中的三元运算符,kotlin中没有三元运算符，当对象A值为null的时候，那么它就会返回后面的对象B

```java
				var name:String = null?:"name"
```



### 区间Range

Range表示一个取之范围  

```java
				var intRange1: IntRange = 0..100;//包含0 和100
				var intRange2: IntRange = 0 until 100;//包含0 不包含100
				val intRange3: IntRange = 0..-1  //不存在
```

```
				// var intRange1: IntRange = 0..100;
        if (i >= 0 && i <= 100) {
        }

        // var intRange2: IntRange = 0 until 100;//包含0 不包含100
        if (i >= 0 && i < 100) {
        }

        // val intRange3: IntRange = 0..-1  //不存在 没有大于等于0同时还小于等于-1的数字
        if (i >= 0 && i <= -1) {
        }
```



### 数组

数组跟java差不多

```java
    var intArray: IntArray = intArrayOf(1, 2, 3, 4, 5)
    var personArray : Array<Person>  = arrayOf(Person("Android", 18, "男"))

    for (i in intArray) {
        println(i)
    }
```



## 程序结构



## 面向对象



## 高阶函数



## 领域特定语言 DSL



## 协程



## 反射语法与库



## 泛型，型变，星投影



## Kotlin与 Java 混合开发






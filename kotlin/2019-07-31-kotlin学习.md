---
layout:     post  
title:      kotlin学习 
subtitle:   kotlin
date:       2019-07-31
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---



[TOC]







##数据类型

### string的比较,== 和equals()

java比较字符串的内存地址用==，kotlin用===

kotlin中的== 和equals()是完全相同的

~~~java
s1 == s2;//相当于java中的equals()
s1 === s2;//相当于java中的==
~~~



### 字符串模板

可以在代码中声明一个变量，在变量前用$修饰，就变成了直接引用该对象。

~~~kotlin
val a = 10
val s = "a = $a" //打印结果为a = 10

val s = "Hello World"
println("s.length=${s.length}")
~~~



### var、val和const

**var：** var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。
**val:** val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。



一个**var**会对应生成两个方法,即getter和setter方法

~~~java
   var title: String? = null
~~~

生成的字节码会包含如下的两个方法和一个backing field

~~~java
    private static String title;
    @Nullable
    public static final String getTitle() {
        return title;
    }

    public static final void setTitle(@Nullable String title) {
        title = title;
    }
~~~



而**val**只会生成一个对应的get方法

~~~java
 val id: Long = 1L
~~~

生成的字节码会包含类似这样的方法

~~~java
   private static final long id = 1L;
    public static final long getId() {
        return id;
    }
~~~



`val定义常量的坑` val并不是真正的常量

通过val定义的变量，只有get方法，没有set方法，所以只能读不能写。
但是其get方法可以复写，从而造成val定义的变量，有可能会发生值变化，情况下面的例子：

~~~java
 val A : Int 
    get()  {
        val rand = Random(System.currentTimeMillis())
        return rand.nextInt()
    }
~~~

val定义的常量A的get()方法被复写，每次调用常量A都会返回一个随机数，所以不能保证常量A的值不变。



const:

const修饰的val变量相当于java中 `static final`是真正意义上的java常量

const关键有以下特点：

- 只能修改val常量。
- const只能修饰顶级属性（位于代码文件的最外部，意思是在结构上常量不属于任何的类，而是属于文件）

~~~java
const val userName: String = "yeqiu"
const val password: String = "yeqiu"
~~~





### 转义字符

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5j0063p8oj30fs09l0t4.jpg)





### ”“”三个引号

使用三个引号(""")包括，内部没有转义，可以包含换行和任何其他文本。所有转义在三个引号中都会失效





### 类和对象

java中创建类

~~~java
				public class Animal {
  
		    private int age;
 		  	private boolean sex;
        private String name;

        public Animal(int age, boolean sex, String name) {
            this.age = age;
            this.sex = sex;
            this.name = name;
      		  }
    		}
~~~

创建一个cat继承Animal

```
				public class Cat extends Animal {

 				   public Cat(int age, boolean sex, String name) {
 				       super(age, sex, name);
				    }

				    public void eat(){
				        System.out.println("猫 调用eat()");
				    }
    
				}
```

在使用上

~~~java
   		 public static void main(String[] args) {
   		     Animal animal = new Cat(1,true,"cat");
   		     if (animal instanceof Cat){
 		           Cat cat= (Cat) animal;
 		           cat.eat();
		        }
		    }
~~~



这是一段很简单的java代码，创建了Animal类，又创建Cat继承Animal，Cat中新加了eat()方法，main()中创建了一个Cat并赋值给了Animal，这里是父类引用指向子类对象。然后又把Animal强转成Cat并调用eat()方法。



以下是kotlin的实现方式

~~~java
				//kotli中所有类默认都是final,可以用open解除
				//constructor是构造方法
				//创建对象时默认执行
				open class Person constructor(var name: String, var age: Int, var sex: String) {

				    init {
				        println("姓名：$name,年龄：$age,性别：$sex")
				    }
				}
~~~



~~~java
				class Coder(name: String, age: Int, sex: String) : Person(name, age, sex) {
 
 				   fun coding() {
 				       println("coding")
 				   }
				}
~~~

~~~java
				fun main(args: Array<String>) {

				    var person: Person = Coder("Android", 18, "男");
				    //相当于java的强转，如果转换失败会抛出异常
				    val coder = person as Coder
				    coder.coding()
				}
~~~





### null安全



~~~java
				public String getName(){
     		   if (true){
       		     return "name";
      		  }else{
      		      return null;
      		  }
    		}
~~~

这是一段很常见的java代码，getName返回一个string，但是也可能会返回null。所有在调用的时候一般都会做*Nullcheck*

~~~java
				fun getName():String{
  				  if (true){
 				       return "name"
				    }else{
				        return null
 				   }
				}
~~~

以上是getName() kotlin的写法，但是这么写在编辑器中会报错。因为方法返回一个string不能返回null，修改为

~~~java
				fun getName(): String? {
				    if (true){
        				return "name"
    				}else{
        				return null
				    }
				}
~~~

这时候编译就没问题了，但是和java的一样都会有null的问题。看看这种写法在用的时候会有什么不一样

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6kvsv0sj30jy0h9dfy.jpg)

这里定义了两个getName()，第一个可能会返回null，第二个不会返回null。在main方法中调用。可以看到第一个在`println(name.length)`的时候报错了。错误如下图;

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6mfx9y6j30hh01ujr8.jpg)

大概的意思就是name这个值可能会是null，用的时候要做判断。改成这样

~~~java
				fun main() {
 				   val name = getName()
 				   val name2 = getName2()
 				   if (name!=null){
  				      println(name.length)
 				   }
 				   println(name2.length)
 				   //上面if中的判断也可以简化成下面这样，意思就是如果name不是null就正常执行否则不执行后续操作
 				    println(name?.length)
      
				}
~~~



还有场景

~~~java
				String name = getName();
        if (name==null){
            return;
        }
~~~

这段也是很常见的，如果name是null直接返回，不在执行下面的代码。kontlin中也可以这么写，但是写完之后编辑器会提示你可以简化成这样

~~~java
				//如果name是null直接return
				val name = getName() ?: return;
~~~

再看这段代码

![原谅我的分号](http://ww3.sinaimg.cn/large/006tNc79ly1g5k6ynshhkj30f1056jr9.jpg)



这里没有对name字段做任何非null的判断，但是在println中并没有报错，因为上一句代码中已经说明如果name是null的话就return(原谅我的分号)



另一种情况

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k7dm1e85j30ah02imwz.jpg)

这里声明了一个可以为null的name，那在调用的时候编译器又会提示*Nullcheck*，但是我知道这里的name不是null，可以换成下面的写法

~~~java
				fun main() {
				    var name:String? = "aaa";
				    println(name!!.length)
				}
~~~

在变量前用!!表示对象非null，如果name真的是null的话同样也会抛出NullPointerException，这个一定要慎用!!

~~~java
 		   //任何的对象都可能存在null的情况
 		  	val notNull: String = null;//编译器报错，notNull对象不能为null
 		  	val nullable: String? = null;//正确，String?表示可以为null
 		   	notNull.length //正确，notNull对象不可能为null可以直接使用
  		  nullable.length //编译器报错，nullable对象可能为null必须先做Nullcheck
  		  nullable!!.length //正确 开发者确认nullable不为null，但是仍有空指针风险，这是很危险的操作
  		  nullable?.length //正确 如果nullable是null直接会返回null并不调用length方法
~~~



最后总结一下，其实在实际开发中null是不可避免的。在ava的编辑器感觉不够重视NullPointerException,我刚工作的时候被null折磨的苦不堪言，甚至改过IDE生成get()的模板来自动生成非null对象。kotlin中同样无法避免null，但是开发时编辑器会自动提示null的安全判断，同时也简化了null的判断（写法上我还是感觉有点怪）,编译器也变得十分智能。其实这并不能叫null安全，只是编辑器强制开发者必须要做*Nullcheck*。





### 类型转换

java中的强转

~~~java
        //创建cat并赋值给animal
        Animal animal = new Cat(1,true,"小猫咪");
        //调用cat中eat方法,必须先进行强转
        if (animal instanceof Cat){
            //强转成cat
            ((Cat) animal).eat();
        }
~~~

kotlin

```java
		var person :Person = Coder("Android",18,"男");
		//is 相当于java中的 instanceof
		if (person is Coder){
		    person.coding()
		}
```

可以看到都需要做强转前的判断，但是kotlin在判断后就不需要在做强转的操作。if成立后编译器认为`person == Coder`

另一个场景

```java
		//这里java会直接报类型转换异常
		Animal animal = new Animal(1,true,"小猫咪");
		((Cat) animal).eat();
```

kotlin

~~~java
		var person: Person = Person("Android", 18, "男");
		(person as Coder).coding()
~~~

这里强转同样会异常，看另一种写法

```java
		//这里在强转的时候使用了as？表示如果强转失败将会等到null，那在调用coding方法的时候判断为null停止调用
		var person: Person = Person("Android", 18, "男");
		val coder: Coder? = person as? Coder
		coder?.coding()
```



### 关于？和！！

**"?"加在变量名后，系统在任何情况不会报它的空指针异常。**
**"!!"加在变量名后，如果对象为null，那么系统一定会报异常！**

**?**到底怎么用。
在声明对象时，把它跟在类名后面，表示这个类允许为null；
在调用对象时，把它跟在对象后面，表示如果为null程序直接返回null并不继续调用

~~~kotlin
    var coder: Coder? = null
    //如果coder == null,coding方法不会执行
    coder?.coding()
    //如果coder == null并不影响这句代码
    println(coder === null)
~~~



然而加上问号以后程序就万事大吉永远摆脱了NullPointerException的烦恼？我们再看下一段代码：

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9jaus0kj30fh03g746.jpg)

报错信息

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9kas1w2j30mj01cdfo.jpg)

大概的意思是 list?.size > 0可能会返回null，null无法跟int进行比较，建议改成`list?.size!! > 0` 

好，一旦改成了这样这里的list就是null那运行到list?.size必然会空指针。看来必须要加上if !=null的判断，

~~~java
    		if (list!=null){
     		    if (list?.size > 0){
     		       println("list的长度不是0")
     		   } 
   		 }
~~~

然后这样就和java一样，有些啰嗦。可以简化成下面这样

```java
				if (list?.size ?: 0 > 0) {
				    println("list的长度不是0")
				}
```

Kotlin提供了`对象A ?: 对象B`表达式，并且取消了Java中的`条件表达式 ? 表达式1 : 表达式2`这个三元表达式。

?:表示的意思是，当对象A值为null的时候，那么它就会返回后面的对象B。

拆开来看上面的代码 list?.size ?: 0 > 0

```java
				val list: ArrayList<String>? = null
				val size = list?.size ?: 0//仅仅在左边的表达式结果为空时才会计算?:后面的表达式
				if (size > 0) {
  				  println("list的长度不是0")
				}
```



关于?:

这个也不是Java中的三元运算符,kotlin中没有三元运算符，当对象A值为null的时候，那么它就会返回后面的对象B

```java
				var name:String = null?:"name"
```



### 区间Range

Range表示一个取之范围  

```java
				var intRange1: IntRange = 0..100;//包含0 和100
				var intRange2: IntRange = 0 until 100;//包含0 不包含100
				val intRange3: IntRange = 0..-1  //不存在
```

```
				// var intRange1: IntRange = 0..100;
        if (i >= 0 && i <= 100) {
        }

        // var intRange2: IntRange = 0 until 100;//包含0 不包含100
        if (i >= 0 && i < 100) {
        }

        // val intRange3: IntRange = 0..-1  //不存在 没有大于等于0同时还小于等于-1的数字
        if (i >= 0 && i <= -1) {
        }
```

区间还可以用来写循环中的条件

~~~java
   for (i in 0 until 10){
       println(i)
   }

		//相当于
    for (int i = 0; i < 10; i++) {
         System.out.println(i);
    }

    for (i in 0 ..10){
        println(i)
    }

		//相当于
    for (int i = 0; i <= 10; i++) {
         System.out.println(i);
    }


~~~





### 数组Array

数组跟java差不多

```java
    var intArray: IntArray = intArrayOf(1, 2, 3, 4, 5)
    var personArray : Array<Person>  = arrayOf(Person("Android", 18, "男"))

    for (i in intArray) {
        println(i)
    }
```

注意：Array != list





## 程序结构

### 函数

函数的写法：必须要以fun关键字开头。标准的函数写法如下：

```java
fun 标准函数(参数:String):Unit{
    //函数体
}
```

Unit和java中的void一样，kotlin中如果返回值是Unit可以省略不写。

```java
fun main(args: Array<String>) {
    test("阿姆斯特朗回旋加速喷气式阿姆斯特朗炮")
    test1("阿姆斯特朗回旋加速喷气式阿姆斯特朗炮")
}

fun test(name: String) {
    println("hi,$name")

}
//单行函数可以直接省去大括号使用=链接 返回值即函数体的范围值
fun test1(name: String) =  println("hi,$name")
//返回两个参数的和  这里的返回值:Int可以省略不写
fun test(x: Int, y: Int): Int = x + y
```

匿名函数

~~~java
val name = fun (name: String) = println("hi,$name")
~~~



### Lambda表达式

lambad表达式其实就是匿名函数的一种写法

基本语法：

`{参数列表 -> 函数体}`函数体的最后一行是返回值

~~~java
val  sum = {a:Int,b:Int -> a+b}
~~~

调用

~~~java
    println(sum(1,2))
    println(sum.invoke(2,3))
    //这里sum小括号其实是一个运算符 相当于调用了invoke方法
~~~



lambad表达式也有类型

```java
/** A function that takes 0 arguments. */
public interface Function0<out R> : Function<R> {
    /** Invokes the function. */
    public operator fun invoke(): R
}
/** A function that takes 1 argument. */
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
/** A function that takes 2 arguments. */
public interface Function2<in P1, in P2, out R> : Function<R> {
    /** Invokes the function with the specified arguments. */
    public operator fun invoke(p1: P1, p2: P2): R
      
      ......
```

Function0,Function1,Function2就是类型

Function0 = 没有参数

Function1 = 1个参数

以此类推



声明一个lambad类型的变量

~~~java
    //声明lambda表达式 类型是 接受两个int参数,返回int结果
    private val sum: (x: Int, y: Int) -> Int

    init {
        //声明之后必须要初始化 初始化就是定义lambda的实现
        //这里只是返回两个数的和
        sum = { x, y -> x + y }
    }
    
    //可以写成这样
    private val sum2:(x: Int, y: Int) -> Int ={x, y -> x + y}
~~~



**lambad表达式是什么**

简单来讲，Lambda是一种函数的表示方式(也就是说一个Lambda表达式等于一个函数)。更确切的说：Lambda是一个未声明的函数，会以表达式的形式传递。Lambda也可以作为参数传递。



**Lambda表达式语法**

1. lambda 表达式总是被大括号括着；

2. 其参数（如果有的话）在 -> 之前声明（参数类型可以省略）(如果没有参数可以省略 ->)
3. 函数体在 -> 后面

   

**具体的写法可以有以下两种写法**

~~~java
// 第一种
val sum1 = {x: Int, j: Int -> x + j}
// 第二种
val sum2: (x: Int, j: Int) -> Int = {a, b -> a + b }
~~~

分析一下上述两种表达式： 
第一种比较好理解，首先 ‘=’ 左边声明了一个变量sum1，’=’ 右边是一个Labmda表达式，然后将其赋值给sum1 
第二种稍微复杂一点，主要是复杂在左边的sum2: 后面的这一坨代表什么意思。 首先Kotlin函数参数是使用 Pascal 表示法定义(name: type)(命名:类型), 因此sum2: 后面的这一坨代表的是一种类型type，(x: Int, j: Int) -> Int这种表述方式就是表达函数的类型，它表示的是一个需要传入两个Int类型参数，并返回Int类型的函数。=后面的大括号表达式即是前面这个lambda的实现。

其实两种写法是一样的。第一种写法是因为kotlin的类型推导，省去了写sum1的类型



**lambda可以作为参数传递**

kotlin中所有的表达式都是有返回值的，没有返回值的返回的是Unit。

~~~java
fun main(args: Array<String>) {
  
    var sum: (x: Int, y: Int) -> Int = { x, y -> x + y }
    test(sum(1,2))
}

fun test(int:Int){
    //do something
}
~~~

以上代码中声明一个test方法需要一个int参数，sum Lambda正好返回一个int。其实这个和java中一样。



**lambda表达式的一些约定**

~~~java
public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {
    for (element in this) action(element)
}
~~~

以上是Array的forEach扩展方法，接受的参数是 一个参数返回Unit类型的表达式

具体调用如下：

~~~java
    val intArray = arrayOf(1, 2, 3)
    intArray.forEach(fun(i: Int) {
        println(i)
    })
~~~

用lambda表达式就是这样

~~~java
intArray.forEach ({i:Int -> println(i)})
~~~

如果传入的参数只有一个可以省略不写，引用时用it来代替，那就变成了这样

~~~java
 intArray.forEach ({ println(it) })
~~~

在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外指定它

~~~java
intArray.forEach () {println(it)}
~~~

在 Kotlin中还有另外一个约定，如果一个函数的参数只有一个，并且参数也是一个函数，那么可以省略圆括号

~~~java
 intArray.forEach { println(it)}
~~~



使用Lambda可以省去接口定义和实现这一环节，但是是有条件的，此接口必须只有一个抽象方法需要实现，才可以使用Lambda替代(比如OnClickListener、OnItemClickListener)。如果多于1个抽象方法，则不能使用Lambda进行替代(比如OnItemSelectedListener)



### 类成员

和java中的属性一样，成员变量，成员方法。

kotlin自动实现了成员变量的set和get方法，可以通过重写去实现

~~~java
class Test {
    //多个成员在变量后面重写get和set
    var a = 10
        //get和set必须进阶写在成员后面 get方法中返回要使用field,不能直接使用变量
      	//field只能在get set中使用
        get() {
            println("重新get方法")
            return field
        }
        set(value) {
            field = value
            println("重新seet方法")
        }

    var b: Int = 20
        get() = field
        set(value) {
            field = value
        }
}
~~~

val修饰的成员是没有set()的



延时初始化

```
var i: Int = 0;
//延时初始化
lateinit var s: String
//延时初始化val
val s1:String by lazy {
    //注意这个只会在使用时执行
    "s1"
}
```



**属性初始化**

**1.属性的初始化尽可能在构造方法中完成 init()**

**2.无法在构造方法中初始化，尝试降级为局部变量（这样的场景比较少）**

**3.var用lateinit延时初始化，val用lazy**

**4.可用类型的变量尽量不要直接用null赋值初始化**



### 分支表达式

分支表达式最基本的就是if语句,用法也和java中一样。

if 表达式也是有返回值的

~~~java
    val int = if (true) {
        0
    } else {
        1
    }
~~~

注意 上面这样的赋值操作分支必须要完善，最后一定要有else





### 中缀表达式

其实就是类似java中`int instanceof Integer`

中缀表达式可以用来自定义运算符，比如 在遍历数组的时候

~~~java
 for (string in strings)
~~~

这里的in就是中缀表达式



1.中缀表达式必须使用infix修饰函数

2.只能有一个参数

~~~java
infix fun String.has(name: String): Boolean {

    return true
}
~~~

~~~java
    val isHas = "北京" has "五道口"
~~~





### when表达式

when表达式可以看成是java中switch的加强版，更加简单暴力且支持任意类型

~~~java
    //按顺序往下执行 任意一条匹配执行后即break跳出
    //default用else代替
    val x = 100
    when (x) {

        0, 1 -> println(" x = $x")

        10 -> println(" x = 10 ...")

        else -> println(" x = else ")
    }
~~~

同样 when表达式也有返回值





### 循环语句

循环语句和java基本一样，有for循环，while循环和do while循环。也有continue 和break关键字



### 异常捕获(try,catch,finally)

异常也和java中一样





### 具名参数，变长参数，默认参数

具名参数其实就是给实参附上形参 

```java
fun sum(a: Int, b: Int) {
    a + b
}
```

```java
sum(a = 1,b = 2)
sum(b = 2,a = 1)
```

在调用的时候指定参数的值，这样计算调换了a和b的位置，他们的值依然不变



变长参数，类似java中的可变参数。但是java中可变参数只能是方法参数的最后一个，kotlin中因为有具名参数的存在不限制可变参数的位置

~~~java
fun test(vararg ints:Int,string: String){
    //doSomething
}
~~~

~~~java
test(1,2,3,string ="test")
~~~



默认参数

给函数的参数设置默认值，如果调用者没有传递参数就使用默认值

~~~java
fun test(double: Double, vararg ints: Int, string: String = "test"){
    //string 有默认值 外界不传值得话就会使用默认值
    
    //doSomething
}
~~~

~~~java
test(0.1,1,2) //调用的时候没有传递string 如果string不是在最后一个，要使用具名参数来指定其他参数
~~~



## 面向对象

### 接口

kotlin中的接口可以有默认实现

~~~java
interface Driver {
    fun drive(){
        println("drive")
    }
}
~~~



### 继承

`open`关键字

kotlin中默认的类和方法都是不能被继承的，需要用open关键字修饰的才能被继承。所有抽象类、抽象方法、接口除外，他们默认就是open的。



接口代理

类似java中的接口继承

~~~java
//定义出两个接口 开车和工作
interface Driver {
    fun drive()
}

interface Work {
    fun work()
}

//定义一个Persion 可以开车和工作
class Persion : Driver, Work {

    override fun drive() {
        //to drive
    }

    override fun work() {
        //to work

    }
}
~~~

Persion继承了Driver和Work，自然要实现各自的抽象方法

~~~java
//定义两个分别实现的类
class CarDriver : Driver {
    override fun drive() {
        println("开车")
    }
}

class PPTWriter : Work {
    override fun work() {
        println("干活")
    }
}

// 定义出Manager 并有其他人代理完成 开车和工作
class Manager(driver: Driver, work: Work) : Driver by driver, Work by work {
    //参数接收 Driver 和 Work ,通过by关键字有传递进来的参数实现抽象方法
    //Manager本身无需再实现 继承的抽象方法

}
~~~

Manager的参数需要Driver 和Work 并将抽象方法教给他们去实现



**继承总结**

**1.父类需要open才能被继承**

**2.父类方法，属性需要open才能复写**

**3.复写需要添加override关键字**

**4.继承写法 `class B : A`**

**5.继承类时实际上是调用了父类的构造方法**

**6.和java一样类只能单继承，接口可以多实现**





### 类及其成员的可见性（private,protected,internal,public）



![](http://ww1.sinaimg.cn/large/006tNc79ly1g5sdo8xikpj30j109gjs1.jpg)



### object

当类用object关键字修饰后就变成了如下的java代码

~~~java
//kotlin中
object  Singleton{
}
~~~

~~~java
//java中
public class Singleton {
    public static Singleton INSTANCE = new Singleton();

    private Singleton(){}

}
~~~

相当于java中创建了一个自身的静态变量并私有了构造，可以直接这么使用

~~~java
object  Singleton{

    fun singleton(){}
}

fun main() {

    Singleton.singleton()

}
~~~



**object关键字修饰**

**1.私有了构造，自身创建静态对象，相当于一个简单的单例模式**

**2.和普通的类一样可以继承，实现接口**

**3.因为私有了构造，不能再创建对象**



### 伴生对象、静态成员和包级函数

java中的静态方法

~~~java
    public static String getName(){
        return "name";
    }
~~~

kontlin中使用object修饰的类，它的方法全都是静态方法。如果要写出像上面java那样的静态方法就要使用伴生对象

~~~java
    companion object{
        fun getName():String{
           return "name"
        }
    }
~~~

getname() 写在companion object中就相对于静态方法。

对于静态变量也是一样的，声明到 companion object 里面就是静态的



包级函数

包级函数并不存在与某个类当中，当需要使用静态方法的时候可以优先考虑包级函数。使用方法也和静态方法类似，但是不需要任何对象或者雷明调用。可以直接调用改方法



### 方法重载

kotlin中的方法重载和java中一样。

重载和重写：

重载：方法名移植，参数不同。与返回值无关

重写：子类集成父类的方法，方法名 参数 返回值都一样。

这里会涉及到一个jvm函数签名的概念，jvm认为函数唯一的标志是根据函数名和参数确定，与返回值无关

java中有个关于重载很不好实现，List 的

```java
List<Integer> list = new ArrayList();
list.remove(1);
list.remove(10);
```

当List中存放的是int时，remove方法将无法删除对应的元素，会默认的调用删除索引的重载方法。

所以开发中应该尽量避免不必要的方法重载



### 扩展成员

就是给现有的类添加方法，属性。有了这个特性那些StringUtils就可以不用了。

```java
fun String.test(){
    println("调用了a")
}

fun main(args: Array<String>) {

    "test".test()
}
```

这段代码直接定义了一个String的扩展方法 test。在main方法中可以直接用string调用test方法



### 属性代理

kotlin的代理模式需要实现一个接口，而属性代理只需要实现getValue和setValue方法即可。

例：

~~~java
//使用by关键字 lazy代理了s1的值
val s1:String by lazy {
    "s1"
}
~~~





### 数据类

使用data关键字修饰类，该类会自动生成

~~~java
equals()
hashCode()
toString()
componentN()
copy()
~~~

data calss被编译器编译后是final 并且没有无参构造，可以通过官方的插件来解决（`noarg`、`allopen`）

但是插件都是在编译后修改字节码文件，在使用时依然无法通过无参构造。

目前感觉这东西没什么卵用。

[noarg、allopen插件的使用](https://www.jianshu.com/p/90a3233b0a8a?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo)



### 内部类(this@Outter,this@Inner)

**内部类就是定义在类内部的类，和java一样**

**kotlin默认是静态内部类，java默认是非静态的**

**非静态内部类使用inner关键字**

**同一个属性名可以使用this@Outter和this@Inner区分**

**静态内部类可以调用外部静态成员，非静态的需要实例化外部类才能访问**

**kotlin中的匿名内部类可以继承其他类**



匿名内部类写法

~~~java
   object : View.OnClickListener {
        override fun onClick(view: View?) {
        }

    }
//相当于
        new View.OnClickListener(){
            @Override
            public void onClick(View view) {

            }
        };
~~~



### 枚举(enum)

枚举就是实例固定的类，使用enum修饰类。

本质其实是私有了构造（构造方法是protected的）的final类，在初始化的时候生成了固定数量的示例。

~~~java
enum class LogLevel(){
    VERBOSE(), DEBUG(), INFO(), WARN(), ERROR(), ASSERT();
}
~~~

上例只能有6个实例，和普通类一样可以有构造，也可以有普通方法



### 密封类(sealed Class)

密封类是子类固定的类，使用sealed修饰

和枚举的区别是：枚举实例固定，密封类是子类可数。

密封类和子类必须写在同一个文件

密封类本身是抽象的，不能直接实例化，构造函数默认是private





## 高阶函数

### 高阶函数的基本概念

以函数作为参数或返回函数的函数被称为高阶函数



函数引用 :

双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法

~~~java
 args.forEach { println(it) }
~~~

此段代码可以写成

~~~java
  args.forEach(::println)
~~~

这里因为forEach接受的参数和println() 接受的参数一致，直接简写成函数引用的方式

这里的println需要的参数会由forEach直接传入，就当成是一种固定写法

这里的println是包级函数 不需要任何对象可以直接调用 



~~~java
fun main(args: Array<String>) {

    args.forEach(::println)

    val helloWorld = Hello::world
    
}

class Hello {

    fun world() {
        println("Hello World")

    }
}
~~~

以上定义了类 Hello 函数world ，那就可以通过类名::函数名 拿到函数引用，注意 这时候有了函数引用并没有真正执行

如果要执行函数的话

~~~java
    val helloWorld = Hello::world
    val hello  = Hello()
    helloWorld(hello)
~~~

这种类方法其实有个隐藏参数就是所在类的本身



~~~java
    args.filter (String::isNotEmpty)
~~~

这里isNotEmpty是String扩展方法，这个和刚才那个差不多，isNotEmpty扩展方法是没有参数的，但是需要用String来调用。相当于isNotEmpty需要一个隐藏参数。



三种引用方式

~~~java
fun main(args: Array<String>) {

    //包级函数
    args.forEach(::println)
    //扩展函数
    args.filter(String::isNotEmpty)
    //普通类函数
    val hello = Hello()
    args.forEach(hello::world)
}

class Hello {
    fun world(any: Any) {
        println("Hello World")

    }
}
~~~



### 常见高阶函数

~~~java
/**
 * map 函数
 * 参数接收一个(T) -> R的表达式 T R 可以是任意类型，两个类型也可以是一样的
 * 功能：遍历一个Array，每次循环遍历的时候执行参数中的表达式并将返回值存储到另一个List中，最终返回这个list
 */
fun mapTest() {

    val ints = arrayOf(1, 2, 3, 4, 5)
    //最原始的写法
    val list1 = ints.map(
        fun(i: Int): Int {
            return i
        }
    )
    //lambda表达式写法
    val list2 = ints.map(
        { i: Int -> i }
    )
    //最终简化后的写法
    val list3 = ints.map { it }
}


/**
 * flatMap 函数
 * 参数接收 transform: (T) -> Iterable<R>  Iterable(可遍历)
 * 遍历每一个元素，并添加到一个总集合中
 */
fun flatMapTest() {

    val intRanges = listOf(1..10, 2..5, 10..15)
    //最原始的写法
    intRanges.flatMap(
        fun(intRange: IntRange): IntRange {
            return intRange
        }
    )

    //lambda表达式写法
    intRanges.flatMap(
        { intRange: IntRange -> intRange }
    )
    //最终简化后的写法
    intRanges.flatMap { it }


    //遍历途中操作一些数据
    intRanges.flatMap { intRange ->
        intRange.map { int ->
            "NO:$int"
        }
    }
    //以上的intRange和int都可以用it代替，为了保证阅读性最好还是写出他们的示例
}

/**
 * reduce 函数
 * 参数接收一个 operation: (acc: S, T) -> S的表达式  S是acc的类型
 * operation即 -> S 的实现 可以相加 可以相乘
 * 功能：遍历一个Array，求和
 */
fun reduceTest() {

    //operation: (acc: S, T) -> S
    val ints = arrayOf(1, 2, 3)

    val reduce = ints.reduce { acc, i -> acc + i }
    println(reduce)
    
    //阶乘示例
    val i = 6
    val factorial = (1..i).reduce { acc, i -> acc * i }
}
~~~



### 闭包

在一个函数A中返回了另一个函数B,只有函数B才可以访问函数A中的内容,这个现象的概念叫做闭包

java中函数是没有状态的，调用完毕后，里面的数据会被回收，不会被保存。java函数中无法在声明其他函数，

~~~java
fun addFun(x: Int): (Int) -> Int {
    return fun(y: Int): Int {
        return x + y;
    }
}
~~~

以上代码定义了一个addFun函数，返回值是一个(Int) -> Int的函数，函数的实现直接返回了一个匿名函数，将两个值相加并返回（这个匿名函数正是add函数的返回值）

~~~java
    val add = addFun(1)
    println( add(1))
~~~

第一次调用addFun函数传入x的值并获取匿名函数的引用，第二次调用传入y的值返回x+y的值

例2

普通函数不携带状态，调用完毕后里面所有的内容就会被释放掉。

~~~java
fun main(args: Array<String>) {    
    test()
}
fun test(){
    var a=3
    println(a);
}
~~~

这段代码无论执行多少次都会输入3



```java
fun main(args: Array<String>) {
    val add = addTest()
    println(add())
    println(add())   
}

fun addTest(): () -> Int {
    var i = 1;
    return fun(): Int {
        return i++
    }
}
```

以上方法拆分开其实首先先获取addTest()的实例，此时并没有真正执行方法，` println(add())`调用add其实是调用addTest()的匿名方法。此方法保存了i的值，所以每次调用add()i的值都会发生变化



~~~java
fun test(x: Int): (y: Int) -> Int {
    return fun(y: Int): Int {
        return x+y
    }
}

fun test(x: Int) = fun (y: Int) = x+y
~~~

这段代码中的两个test函数 是一样的



**闭包的总结**

函数里面声明函数，函数里面返回函数，就是闭包。闭包函数的变量在执行完后仍不会被释放



todo

闭包什么时候释放



### 复合函数

Todo

~~~java
fun main(args: Array<String>) {

    val value = multiply(add(1))
    println(value)
    val compound = ::add compound ::multiply
    println(compound(1))

}
fun add(int: Int): Int {
    return int + 1
}
fun multiply(int: Int): Int {
    return int * 2
}

/**
 * multiply(add(1)) 先执行add函数返回值传入了multiply并获得一个返回值
 * Function1的扩展方法，方法接收一个Function1，返回值也是一个Function1
 * compound作为add的扩展方法 参数接受的Function1就是multiply
 * Function1<P1, P2> = add
 * 参数 Function1<P2, R> = multiply
 * compound = add（multiply（1））
 * 方法的实现 function.invoke(this.invoke(p1))
 * this = Function1<P1, P2> = add
 * function =  Function1<P2, R> = multiply
 * p1 = add()的值
 * p2 = 传入的值
 * R = 最终返回值
 *
 */
infix fun <P1, P2, R> Function1<P1, P2>.compound(function: Function1<P2, R>): Function1<P1, R> {
    return fun(p1: P1): R {
        return function.invoke(this.invoke(p1))
    }
}
~~~





### 柯里化（Currying）-函数调用链

Todo



### 偏函数

todo







## 领域特定语言 DSL

### DSL 的基本概念



### 小案例：HTML DSL开发



### Gradle Kotlin 脚本编写



## 协程

### 协程入门



### 协程的启动模式



### 程的调度



### 协程的异常处理



### 协程的取消机制



### 协程的挂起原理分析



### 序列生成器



### 在 Android 中使用协程



### 协程总结



## 反射语法与库

### Kotlin中使用 Java 反射



### Kotlin 反射库的注意事项



## 泛型，型变，星投影

### 泛型的基本语法



### 泛型的实现机制



### 泛型的实现机制



### 型变



### 星投影



## Kotlin与 Java 混合开发

### 基本互操作



### SAM 转换



### 正则表达式



### 集合框架



### IO 操作



### 装箱和拆箱



### 注解处理器



### 混合开发总结





[forEach 跳出的问题](https://coding.imooc.com/learn/questiondetail/108331.html)

闭包什么时候释放
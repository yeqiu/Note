---
layout:     post  
title:      高阶函数和Lambda表达式 
subtitle:   高阶函数和Lambda表达式
date:       2020-05-29
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---



[TOC]

### 高阶函数

函数和方法是一个东西，java中的方法在kotlin中更多的被称为函数。

#### 函数调用

和java一样，调用函数是很简单的。

~~~kotlin
fun fun1(){
    println("fun1")
}

fun fun2(str:String){
    println(str)
}

fun main(args: Array<String>) {
    fun1()
    fun2("test")
}
~~~

无参函数可以直接调用，有参函数需要传入参数调用。

函数传参也没啥好说的，但是当参数类型是另一个函数的时候。java的语法就不允许这么操作了。但是我们有个历史悠久的变通方案，通过接口。比如Android里的各种Listener，设置监听的时候方法参数接受一个接口。其实我们并不是需要接口，而是需要实现接口的方法。而在kotlin中可以直接传递函数作为参数。

~~~kotlin
fun fun3(function:(Int)->Unit){
    
}
~~~

参数写法与普通的参数写法也很类似，参数是函数的写法是

 `(参数类型)->返回值`，没有参数可以使用空括号，无返回值使用Unit。

以上代码中参数是一个 接受int类型的参数无返回值的函数。

另外，函数不光可以作为参数，还可以作为返回值

~~~kotlin
fun fun4(i:Int):(Int)->Unit{

}
~~~

像这样参数或者返回值是另一个函数的的函数就是高阶函数。高阶函数只是对这类函数的叫法，并没有特殊含义。



### 函数引用

面向对象的本质是将对象传递使用，但是函数本身并不是一个真正的对象。kotlin在实现函数作为参数的时候创建一个和函数一样的对象，创建的方式就是使用双冒号::`::fun1`。相对于将函数赋值给一个变量

~~~kotlin
 val f = ::fun1
~~~

当函数左侧使用了::的时候，它就不是这个函数本身而是函数对象。调用函数对象的时候实际上会调用这个对象的`invoke()`函数。

注意 函数引用是指向一个函数对象的引用，但并不是函数本身。



### 匿名函数

上面赋值的写法相对于是这样的

~~~kotlin
val f = fun fun5(i:Int):Unit{   
}
~~~

这种写法IDE会提示报错，会让你去掉函数名 fun5

~~~kotlin
val f = fun(i:Int):Unit{
}
~~~

变量f指向的就是一个匿名函数



### Lambda表达式

其实Lambda表达式就是匿名函数，对一些符合特殊条件的匿名函数可以使用更简洁的方式。

1.如果是函数的最后一个参数，可以把这个函数写到括号的外面

~~~kotlin
view.setOnClickListener() { v: View ->
 
}
~~~

2.如果参数只有一个匿名函数，可以直接把括号去掉

~~~kotlin
view.setOnClickListener { v: View ->
}
~~~

3.如果这个函数只有一个参数，那参数也可以省略不写。使用的时候用it代替

~~~kotlin
view.setOnClickListener {
  it.xxx
}
~~~

Lambda表达式的参数类型和返回值类型可以通过上下文的推断。

~~~kotlin
fun setOnClickListener(onClick: (View) -> Unit) {
  this.onClick = onClick
}
~~~

声明`setOnClickListener`的时候参数指定为一个View类型无返回值的函数，所以在调用的时候可以通过推断知道it就是View。



要把匿名函数赋值给一个变量的时候可以简写成 Lambda 的形式：

~~~kotlin
val fun1 = fun(i: Int): String {
    return i.toString()
}

val fun2 = { i: Int ->
     i.toString()
}
~~~

注意：Lambda的返回值不使用return来返回，而是直接用最后一行代码的值。如果Lambda中有return，它会把这个作为外部函数的范围值，直接结束外部的函数。





### 匿名函数和 Lambda


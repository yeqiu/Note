---
layout:     post  
title:      Kotlin 数据类型
subtitle:   数据类型
date:       2021-07-01 
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

## 泛型基本概念

kotlin的泛型是根据java来的。泛型的本质就是 参数化类型。将所操作的不确定的数据类型定义为一个未知的参数类型。

### 泛型的优点

- 类型安全
- 消除强制类型转换
- 提高代码的重用性

```java
public <T> T getMax(T a,T b){
    return a;
}
```

###  类型擦除

java的泛型是一种伪泛型，采用的是类型擦除机制来支持泛型。泛型只存在于代码的编译前，再编译后泛型会被擦除。Java的泛型再代码运行时并不能知道泛型参数的类型。

### 声明

泛型函数：

```kotlin
fun <T> getMax(a: T, b: T): T {
    return a
}
```

泛型类，泛型接口：

```kotlin
class KGeneric<T>(val t: T) {
    
}
```



## 泛型的限定

上例中的`getMax`函数实现

```kotlin
fun <T> getMax(a: T, b: T): T {
    return if (a > b) a else b
}
```

这里`a > b`会报错，并不是所有的类型都具备比较的功能。所以需要传入的泛型类型具备比较的功能，这里可以让T实现`Comparable`

```kotlin
fun <T : Comparable<T>> getMax(a: T, b: T): T {
    return if (a > b) a else b
}
```

通过`: Comparable<T>`给泛型添加一个限定，必须是Comparable的子类。

## 型变

### java 泛型

java本身的泛型是不变性质的。java中 `List<Father>`并不是`List<Son>`的父类。不能把一个子类的`List`赋值给父类的`List`。 因为泛型擦除的关系，在代码编译后泛型会消失，为了保证类型安装。java的泛型就不具备多态的特性了。

```java
//多态 子类对象实例可以赋值给父类引用
Father father = new Son();
```

```java
//多态在泛型中就不适用了
List<Father> fathers = new ArrayList<Son>();
```



### 协变

协变的意思是子类泛型也是泛型类型的子类。按照协变的意思，子类的`List`可以赋值给父类的`List`。

java提供了泛型通配符?解决这些问题。

#### ? extends

上界通配符，可以使java泛型具备协变的特性。

- ？表示泛型的类型是一个未知类型
- extends限制了泛型的父类上限

```java
List< ? extends Father> fathers = new ArrayList<Son>();
```

使用协变实例的赋值可以是 Father本身，Father的直接子类，Father的间接子类。

上例中 `Son`是`Father`的子类，可以满足 `extends Father`的条件。

#### 带来的问题

```java
List< ? extends Father> fathers = new ArrayList<Son>();
Father father = fathers.get(0);
fathers.add(new Father());//这行会报错
```

在使用协变的时候不能调用设置泛型参数的方法。也就是不能给泛型实参赋值。只能获取泛型参数，不能修改泛型参数。

#### 原因

在定义泛型的时候设置的是`extends Father`，也就是只要是继承自`Father`的泛型都可以，所以使用`List<Son>`可以赋值。

但是在泛型擦除后，就不存在泛型了。协变只是限制了泛型的上限必须是`Father`但并不知道具体的类型，为了保证数据安全，干脆就无法设置泛型类型的参数。

### 逆变

逆变和协变一样都是可以扩大实际赋值的类型范围。扩大的范围正好和协变相反。

#### ? super

逆变使用下界通配符，正好与协变相反。它可以把父类的泛型类型对象赋值给子类的泛型类型。

```java
List<? super  Son> sons = new ArrayList<>();
```

- ? super 限定了泛型的下限，必须是Son的父类。

- 这里泛型的范围可以是`Son`本身，父类，间接父类。

#### 带来的问题

和协变一样也会有数据的问题。正好和协变反过来。

```java
List<? super Son> sons = new ArrayList<Father>();
Object object = sons.get(0);
sons.add(new Son());
```

带来的问题和协变相反。在使用逆变的时候，可以修改泛型参数，不能调用包含泛型参数的返回值。

#### 原因

使用`? super Son`限制了赋值的泛型实际参数必须是`Son`的父类。

在设置泛型参数的时候必须满足`super Son`的限制，也就是设置泛型参数的时候必须是`Son`本身或者子类。但是在获取参数的时候因为泛型擦除，并不知道实际给`List<? super Son>`赋值的是什么，可能·是`Son`本身或者他的父类，那就只能向上取值，获取到的就是`Object`。可以通过强制转换把`Object`转成实际的类型。



## in out

协变和逆变在kotin中换了一种写法。

```java
//java
//协变
List<? extends Father> fathers = new ArrayList<Son>();
//逆变
List<? super Son> sons = new ArrayList<Father>();
```

~~~kotlin
//kotlin
//协变
val fathers: List<out Father> = ArrayList<Father>()
//逆变
var sons:MutableList<in Son> = ArrayList<Father>()
~~~

In 和 out对应java中的通配符写法。

**in：泛型变量只能输出，不能输入**

**out：泛型变量只能输入，不能输出**

in和out可以直接写在泛型声明的地方，为了避免在每个使用的地方都使用in和out可以直接在类声明出使用。比如kotlin的List

~~~kotlin
public interface List<out E> : Collection<E> 
~~~

这种写法直接就支持逆变或者协变。



## 星投影



## 泛型的实现类





## 内联特化





## 案例






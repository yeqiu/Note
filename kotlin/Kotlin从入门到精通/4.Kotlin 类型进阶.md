---
layout:     post  
title:      Kotlin 数据类型
subtitle:   数据类型
date:       2021-07-01 
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

## 构造器

### 基本写法

~~~kotlin
class User constructor(var name:String,var age:Int){
    
}
~~~

`constructor(var name:String,var age:Int)`就是一个构造函数，通常会省略constructor关键字。

这种写到类名后面的构造函数也叫主构造函数。kotlin允许一个类有多个构造函数，但是其他构造函数必须直接或者减间接的访问主构造函数。

~~~kotlin
class User constructor(var name:String,var age:Int){
    
    constructor(name: String):this(name,18){
        //访问主构造器
    }
    constructor():this("狗蛋"){
        //访问上一个构造器
    }
}
~~~



### 构造函数

主构造函数没有函数体，如果有逻辑处理需要在 `init`代码块中进行。

```kotlin
class User constructor(var name:String,var age:Int){

    init {
        println("User")
    }
    
}
```

init代码块可以存在多个，会在构造时合并到一起执行。



### 参数可见性

在构造函数中使用 var或val修饰的变量再类中可见，没有修复的变量仅仅在init代码块中可见。



### 继承

继承父类需要访问父类的主构造函数

```kotlin
open class Person(var name:String,var age:Int){

}

class User constructor(name:String, age:Int):Person(name,age){

    init {
        println("User")
    }
}
```



## 成员可见性

- `public`：公开，可见性最大，哪里都可以引用。kotlin中默认就是public
- `private`：私有，可见性最小，根据声明位置不同可分为类中可见和文件中可见。
- `protected`：保护，自身子类可见。
- `internal`：内部，仅对 module 内可见。

|   类型    |      java      |     kotlin     |
| :-------: | :------------: | :------------: |
|  public   |      公共      |   与java相同   |
| internal  |       —        |   模块内可见   |
|  default  |    包内可见    |       —        |
| protected | 包内和子类可见 | 类内和子类可见 |
|  private  |    类内可见    | 类或文件内可见 |



kotlin中默认的修饰符是 `public`



## 属性延迟初始化

kotlin要求变量再声明时必须初始化。

1.变量声明成可空类型，使用时做非空判断。

`private var int:Int? = null`

2.使用 lateinit 延时初始化，不能用来修饰基本数据类型。

`private lateinit var str:String `

3.代理，使用`lazy`

```kotlin
private val i:Int by lazy { 
    100
}
```



### 注意事项

1.属性的初始化尽可能在构造方法中完成 init()

2.无法在构造方法中初始化，尝试降级为局部变量（这样的场景比较少）

3.尽可能用lazy代替lateinit

4.可用类型的变量尽量不要直接用null赋值初始化



### lateinit 与 by lazy (委托机制)的应用与区别

**lateinit：**延时初始化

lateinit标示着某个变量将会在稍后的操作中进行初始化，是用来对不可空的var变量进行操作的，对val变量无法进行操作。

lateinit标示的值可被多次赋值

**by lazy** 代理

val变量相当于java中的**final**变量，只能赋值一次

~~~java
    val str: String by lazy {
        "str"
    }
~~~

by lazy 只会在s1为null 的时候执行。



## 代理

代理的意思就是 **A 代替 B 去 doSomeThing**

### 接口代理

对象 X 代替 当前类A实现接口B的方法。

案例:

~~~kotlin
//定义出两个接口 开车和工作
interface Driver {
    fun drive()
}

interface Work {
    fun work()
}

//定义一个Person 可以开车和工作
class Person : Driver, Work {
    override fun drive() {
        //to drive
    }

    override fun work() {
        //to work
    }
}

//定义两个分别实现的类 司机实现开车接口，工人实现工作接口
class CarDriver : Driver {
    override fun drive() {
        println("开车")
    }
}

class Worker : Work {
    override fun work() {
        println("干活")
    }
}

// 定义出Manager 实现开车和工作接口，并有其他人代理完成 开车和工作
class Manager(driver: Driver, work: Work) : Driver by driver, Work by work {
    //参数接收 Driver 和 Work ,通过by关键字有传递进来的参数实现抽象方法
    //Manager本身无需再实现 继承的抽象方法
}
~~~



### 属性代理

属性代理就是 对象X代替属性A实现 set/get函数。

lazy就是代理的变量的get函数。

~~~kotlin
private val i:Int by lazy { 
    100
}
~~~

lazy的源码

```kotlin
public actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)

private class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    // final field is required to enable safe publication of constructed instance
    private val lock = lock ?: this

    override val value: T
        get() {
            val _v1 = _value
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress("UNCHECKED_CAST")
                return _v1 as T
            }

            return synchronized(lock) {
                val _v2 = _value
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress("UNCHECKED_CAST") (_v2 as T)
                } else {
                    val typedValue = initializer!!()
                    _value = typedValue
                    initializer = null
                    typedValue
                }
            }
        }

    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE

    override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet."

    private fun writeReplace(): Any = InitializedLazyImpl(value)
}
```





## 单例 object

```kotlin
object SingleInstance{
    
}
```

以上代码相当于java中

```java
public class SingleInstance {

    public static final SingleInstance INSTANCE = new SingleInstance();

}
```

object 定义的是一个饿汉式的单例，当类加载时候就会被初始化。在其中定义函数和变量也和普通类一样。访问的时候无需实例化就能访问。

```kotlin
fun main() {

    SingleInstance.x
    SingleInstance.y()
}

object SingleInstance {
    var x = 2
    fun y(){
    }
}
```



### 伴生对象

java中可以定义静态方法

~~~java
    public static String getName(){
        return "name";
    }
~~~

在 `Kotlin` 里，静态变量和静态方法这两个概念被去除了。那如果想在 Kotlin 中像 Java 一样通过类直接引用可以使用 `companion object`

~~~java
    companion object{
        fun getName():String{
           return "name"
        }
    }
~~~

`ompanion object` 可以理解为伴随、伴生，表示修饰的对象和外部类绑定。一个类中最多只能有一个伴生对象



## 内部类



## 数据类





## 枚举



## 密封类





## 案例








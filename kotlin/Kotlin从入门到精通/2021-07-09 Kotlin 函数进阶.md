---
layout:     post  
title:      Kotlin 数据类型
subtitle:   数据类型
date:       2021-07-01 
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

## 扩展函数

扩展成员用于补充原生类的成员。

使用扩展函数可以用新加入的函数用的和原生的一样

### 定义

`fun 类名.函数名`

~~~kotlin
fun String.print(){
    print(this)
}

fun main(args: Array<String>) {
    "kotlin".print()
}

~~~

以上定义一个String的扩展函数print，用于打印这个字符串。再其他地方可以直接使用字符串调用这个函数。



## 函数类型

再kotlin中函数也有类型

```kotlin
fun sum(x:Int,y:Int):Int{
    return x+y
}
```

以上sum函数的类型为 接受两个int参数，返回一个int的值。`(Int,Int)->Int`。其他函数的类型以此类推。

函数类型的特点

(A, B) -> C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -> A。Unit 返回类型不可省略。



## 函数引用

使用双冒号：标识对这个函数的引用。

```kotlin
class Test {

    fun sum(x: Int, y: Int): Int {
        return x + y
    }

}
```

函数有类型也可以被指向到其他变量。上例中的sum函数可以被赋值给变量f

~~~kotlin
val  f: KFunction3<Test, Int, Int, Int> =Test::sum
~~~

使用`Test::sum`可以引用到Test对象中的sum函数，这里的KFunction3是kotlin内置的一种函数类型，所有的函数类型都是KFunction的变式。

调用函数

```kotlin
f(Test(),1,2)

f.invoke(Test(),1,2)
```

invoke是()的运算符函数，作用是一样的。调用时需要先传入一个Test对象，然后传入sum函数的参数。

因为声明变量f的时候没有设置Test对象，所以再调用需要传入对象。也可以在声明变量的时候先设置Test对象

~~~kotlin
    val test = Test()
    val  f: KFunction2<Int, Int, Int> =test::sum
    f.invoke(1,2)
~~~

注意这里函数的类型变成了KFunction2。

以下是部分函数类型的源码

~~~kotlin
/** A function that takes 0 arguments. */
public interface Function0<out R> : Function<R> {
    /** Invokes the function. */
    public operator fun invoke(): R
}
/** A function that takes 1 argument. */
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
/** A function that takes 2 arguments. */
public interface Function2<in P1, in P2, out R> : Function<R> {
    /** Invokes the function with the specified arguments. */
    public operator fun invoke(p1: P1, p2: P2): R
      
      ......
~~~

Function0 = 没有参数

Function1 = 1个参数



**注意：函数引用被赋值的时候并没有执行函数，只用调用invoke才会执行函数**



## lambda表达式

lambda表达式是一种匿名函数，以表达式的形式传递。可以作为参数或者返回值。

~~~kotlin
fun sum(x: Int, y: Int): Int {
    return x + y
}
//lambda表达式改写sum函数
val sum = {x: Int, y: Int -> x+y}
~~~

### 语法

1.表达式需要被大括号包裹。

2.如果有参数的的话需要放在 ->之前 (如果没有参数可以省略 ->)

3.再 ->之后紧跟函数体

` {参数列表 -> 函数体 }`

~~~kotlin
    val sum = { x: Int, y: Int -> x + y }
    
    val sum2: (Int, Int) -> Int = { x, y -> x + y }
~~~

这两种写法是一样的，第一种通过Kolint的类型推到，可以识别到 sum的类型是 两个Int类型的参数返回一个Int类型的值。

第二种方式是直接显示的写好类型，后面引用的时候省去了参数的类型。



## 高阶函数

高阶函数的定义：

1.当这个函数的参数是包含至少一个其他函数作为参数。

2.返回值为一个函数

当满足其中一点的函数就可以被称为高阶函数。

![](https://tva1.sinaimg.cn/large/008i3skNly1gt3lqxa273j30us0ch0tt.jpg)



### 简化规则

- 在函数中，最后一个参数是函数类型，那么可以将 Lambda 可以移到函数的括号外面。
- 如果函数的参数只有一个 Lambda ，那么函数的小括号可省略。
- 在 Lambda 表达式中只有一个参数，可以使用默认参数 it 进行替代。



## 内联函数

因为高阶函数的缘故，再实际运行时kotlin会为函数创建临时对象。

~~~kotlin
fun main() {

    highOrderFun {
        println("highOrderFun")
    }
}

fun highOrderFun(block:()->Unit){

    block()
}

~~~

这段代码编译后是这样的

~~~kotlin
public final class TestKt {
   public static final void main() {
      highOrderFun((Function0)null.INSTANCE);
   }

   // $FF: synthetic method
   public static void main(String[] var0) {
      main();
   }

   public static final void highOrderFun(@NotNull Function0 block) {
      Intrinsics.checkNotNullParameter(block, "block");
      block.invoke();
   }
}
~~~

main函数再调用highOrderFun时创建了Function0对象。如果再循环中调用高阶函数就会创建大量的临时对象，这时就用到内联函数。

**内联函数可以将函数的内容直接植入到调用出。节省函数压栈和出栈的资源**

被`inline`标记的函数就是内联函数,其原理就是:在编译时期,把调用这个函数的地方用这个函数的方法体进行替换

```kotlin
fun main() {
    sum(1,2)
}

inline fun sum(x: Int, y: Int): Int {
    return x + y
}
```

以上代码相当于直接在main函数中直接执行1+2。

### noinline

当内联函数的返回值是函数时

~~~kotlin
fun main() {
    highOrderFun {
        println("highOrderFun")
    }
}

inline fun highOrderFun( block: () -> Unit): () -> Unit {
    block()
    return block
}

~~~

这种写法会报错。内联函数的函数参数只能被直接调用或者传递给另一个内联函数，除此之外不能用作他用。使用`noinline`关键字可以突破这个限制，但也会失去内联特性。

~~~kotlin
inline fun highOrderFun( noinline block: () -> Unit): () -> Unit {
    block()
    return block
}
~~~



### 内联函数中的return

在普通的lambda表达式中不允许使用return。

```kotlin
fun main() {
    highOrderFun {
        println("main")
      	//这里return会报错
        return
    }
}
```

但是在内联函数中可以return。**内联函数编译后直接将代码植入到调用处，相当于return是调用函数，并不是这个内联函数。**

~~~kotlin
fun main() {
    val ints = intArrayOf(1, 2, 3, 4, 5)
    ints.forEach {
        if (it ==3){
            return
        }
        println(it)
    }
    println("end")
}
~~~

以上代码并不会输出 end，forEach是一个内联函数，再编译后会直接被替换到main函数中，使用return将终止main函数。

这里是没有办法终止循环的，但是可以使用标签

~~~kotlin
fun main() {
    val ints = intArrayOf(1, 2, 3, 4, 5)
    ints.forEach {
        if (it ==3){
            return@forEach
        }
        println(it)
    }
    println("end")
}
~~~

使用 ` return@forEach`的效果和`continue`一样，跳过本次循环，继续下次循环。

### non-local return

~~~kotlin
ints.forEach {
        if (it ==3){
            return
        }
    }
~~~

这种直接在lambda表达式中return的叫 `local return`。

有些时候允许`local return`会产生一些问题。

```kotlin
fun main() {
    inlineFun { 
        println("main")
    }
}

inline fun inlineFun( crossinline block: () -> Unit) {
    noinlineFun{
        //这里调用block会报错
        block.invoke()
    }
}

fun noinlineFun(block: () -> Unit) {
}
```

再内联函数中调用其他非内联函数，传递参数时候无法确定block中是否有return。如果有的话这里就和在普通的lambda表达式return一样。无法确定return的那个函数。编译器不允许这种操作。除非noinlineFun是一个内联函数，或者使用`crossinline`来限制传入的函数参数中不能使用return，但是还是可以使用return@标签的形式来return当前的内联函数。

~~~kotlin
fun main() {
    inlineFun {
        println("main")
        //这里会报错，因为crossinline限制不可return
        return
    }
}

inline fun inlineFun( crossinline block: () -> Unit) {
    noinlineFun{
        //使用 crossinline 可以消除报错
        block.invoke()
    }
}

fun noinlineFun(block: () -> Unit) {
}
~~~



## 内置高阶函数

### let

### run

### also

### apply

### use









## 集合变换和序列





## 序列转换










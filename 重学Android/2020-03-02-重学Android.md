---
layout:     post  
title:      重学Android 
subtitle:   Android 
date:       2020-03-02
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---



[toc]





## Activity

### 生命周期

其实生命周期没啥好说的了，需要注意的是`onRestart()`，平时对这个方法的时候用比较少。

`onRestart()`的调用时机是在`onStop()`之后又重新进入前台显示。例如A跳转到B，然后返回到A。

#### onSaveInstanceState()

当`Activity`进入停止状态可能会被系统回收，回到这个页面会重新执行`onCreate()`，看似没毛病，但是销毁之前的临时数据都会丢失。系统提供了`onSaveInstanceState()`，函数中提供了一个参数`Bundle`用来保存了数据，数据会被带回到``onCreate()``中的`Bundle`。

`onSaveInstanceState()`的调用时机：

1、当用户按下手机home键的时候。

2、长按手机home键或者按下菜单键时。

3、手机息屏时。

4、A启动B，A就会调用，也就是说打开新Activity时，原Activity就会调用。

5、默认情况下横竖屏切换时。

当竖屏切换到横屏时，系统会销毁竖屏Activity然后创建横屏的Activity，所以竖屏被销毁时，该方法就会被调用。

### onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) 

初学者在重写`onCreate()`的时候一定有遇到过明明以及指定了布局文件，页面还是一片白色。这是因为重写的是这个两个参数的`onCreate()`函数。在5.0之后系统多出来一个`onCreate()`的重载函数

~~~kotlin
override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) {
        super.onCreate(savedInstanceState, persistentState)
    }
~~~

当手机由于断电或者死机等原因异常关机，就可以通过这个函数来找回临时数据。这个方法只能被标记为`android:persistableMode="persistAcrossReboots"`的`Activity`的调用。

另外`onSaveInstanceState()`也有两个参数的重载

```kotlin
override fun onSaveInstanceState(outState: Bundle, outPersistentState: PersistableBundle) {
    super.onSaveInstanceState(outState, outPersistentState)
}
```

这里的`outPersistentState`就是用来做持久化数据的。



### 启动模式

standard：默认的启动模式，不需要配置。每次打开一个Activity都会在栈中加入。
singleTop：栈顶复用模式，当要打开的Activity已经处于栈顶就直接复用。
singleTask：栈内复用默认，只要打开的Activity已经在栈内就直接复用。
singleInstance：单独返回栈，启用一个新的返回栈来管理这个Activity。

注意：singleInstance模式的Activity会独占一个栈。

场景 A B C三个Activity，B的启动模式是singleInstance。依次启动ABC，关闭C页面会返回到A，然后才能返回到B。因为A C存在于一个栈内。



## Fragment

关于`fragment`的基础知识什么好说的。

### 添加返回栈

`fragment`也可以像`Activity`那样相应返回键。

```kotlin
supportFragmentManager.beginTransaction()
        //todo 设置fragment
    .addToBackStack("name")
    .commit()
```

`addToBackStack`可以传入一个名字

[简析 addToBackStack使用和Fragment执行流程](https://blog.csdn.net/wenxuzl99/article/details/16112725)



## 广播接受者 BroadcastReceiver

从Andorid 8.0系统之后所有隐式广播不允许使用静态注册的方式接受。隐式广播就是没有指定那个应用接受的广播。多数系统广播都属于隐式广播。



### 发送广播

~~~ kotlin
    private fun sendReceiver() {
        
        val intent = Intent("action")
        intent.setPackage(packageName)
        sendBroadcast(intent)
        
    }
~~~

1.创建Intent 传入action。

2.指定广播发送给那个应用的包名

3.发送广播

第二步很重要，要指定接收应用的包名。



### 广播的生命周期

广播的生命周期的生命周期很短，只有一个`onReceive`函数



### 广播的应用场景

广播可以用户单点登录中的强制下线，或者微信支付中页面回调时发送广播。但广播的应用场景大多都可以被`EventBus`代替。



## 服务Service







## 多线程编程

`Andorid`中的多线程和java一样，基本使用相同的语法。

集成`Thread`或者实现`Runnable`

`Andorid`中的多线程编程主要是指多线程通信。

`Andorid`中必须在主线程中更新`UI`，否则会出现异常。`Andorid`提供了一套异步小时处理机制，用于解决子线程中进行`UI`操作的问题。

### Handler

Handler的异步消息处理只要由4个部分构成：`Message`，`Handler`，`MessageQueue`，`Lopper`

#### Message

`Message`是线程之间传递的消息，它可以内部携带一些信息。在不同的线程中传递。

#### Handler

`Handler`用户发送和处理消息，通过`sendMessage()`发送的消息经过一系列辗转后会传递到`handleMessage()`中处理

#### MessageQueue

消息队列，用户存储发送的消息，消息会被存在于队列中，等待被处理。每个线程只会有一个`MessageQueue`对象

#### Lopper

循环，是`MessageQueue`的管家，是一个无限循环，当发现队列中有消息时候，就会将它取出发送给`Handler`处理。每个线程也只会有一个`Lopper`对象



### 异步消息的处理流程

在主线程创建一个`Handler`对象，当子线程需要进行`UI`操作时，就创建一个`Message`对象，通过`Handler`发送到`MessageQueue`中等待处理，然后由`Lopper`循环取出分发到

`Handler`的`handleMessage()`函数中。


---
layout:     post  
title:      重学Android 
subtitle:   Android 
date:       2020-03-02
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---



[toc]





## Activity

### 生命周期

其实生命周期没啥好说的了，需要注意的是`onRestart()`，平时对这个方法的时候用比较少。

`onRestart()`的调用时机是在`onStop()`之后又重新进入前台显示。例如A跳转到B，然后返回到A。

#### onSaveInstanceState()

当`Activity`进入停止状态可能会被系统回收，回到这个页面会重新执行`onCreate()`，看似没毛病，但是销毁之前的临时数据都会丢失。系统提供了`onSaveInstanceState()`，函数中提供了一个参数`Bundle`用来保存了数据，数据会被带回到``onCreate()``中的`Bundle`。

`onSaveInstanceState()`的调用时机：

1、当用户按下手机home键的时候。

2、长按手机home键或者按下菜单键时。

3、手机息屏时。

4、A启动B，A就会调用，也就是说打开新Activity时，原Activity就会调用。

5、默认情况下横竖屏切换时。

当竖屏切换到横屏时，系统会销毁竖屏Activity然后创建横屏的Activity，所以竖屏被销毁时，该方法就会被调用。

### onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) 

初学者在重写`onCreate()`的时候一定有遇到过明明以及指定了布局文件，页面还是一片白色。这是因为重写的是这个两个参数的`onCreate()`函数。在5.0之后系统多出来一个`onCreate()`的重载函数

~~~kotlin
override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) {
        super.onCreate(savedInstanceState, persistentState)
    }
~~~

当手机由于断电或者死机等原因异常关机，就可以通过这个函数来找回临时数据。这个方法只能被标记为`android:persistableMode="persistAcrossReboots"`的`Activity`的调用。

另外`onSaveInstanceState()`也有两个参数的重载

```kotlin
override fun onSaveInstanceState(outState: Bundle, outPersistentState: PersistableBundle) {
    super.onSaveInstanceState(outState, outPersistentState)
}
```

这里的`outPersistentState`就是用来做持久化数据的。



### 启动模式

standard：默认的启动模式，不需要配置。每次打开一个Activity都会在栈中加入。
singleTop：栈顶复用模式，当要打开的Activity已经处于栈顶就直接复用。
singleTask：栈内复用默认，只要打开的Activity已经在栈内就直接复用。
singleInstance：单独返回栈，启用一个新的返回栈来管理这个Activity。

注意：singleInstance模式的Activity会独占一个栈。

场景 A B C三个Activity，B的启动模式是singleInstance。依次启动ABC，关闭C页面会返回到A，然后才能返回到B。因为A C存在于一个栈内。



## Fragment

关于`fragment`的基础知识什么好说的。

### 添加返回栈

`fragment`也可以像`Activity`那样相应返回键。

```kotlin
supportFragmentManager.beginTransaction()
        //todo 设置fragment
    .addToBackStack("name")
    .commit()
```

`addToBackStack`可以传入一个名字

[简析 addToBackStack使用和Fragment执行流程](https://blog.csdn.net/wenxuzl99/article/details/16112725)



## 广播接受者 BroadcastReceiver

从Andorid 8.0系统之后所有隐式广播不允许使用静态注册的方式接受。隐式广播就是没有指定那个应用接受的广播。多数系统广播都属于隐式广播。



### 发送广播

~~~ kotlin
    private fun sendReceiver() {
        
        val intent = Intent("action")
        intent.setPackage(packageName)
        sendBroadcast(intent)
        
    }
~~~

1.创建Intent 传入action。

2.指定广播发送给那个应用的包名

3.发送广播



### 广播的生命周期

广播的生命周期的生命周期很短，只有一个`onReceive`函数



### 广播的应用场景

广播可以用户单点登录中的强制下线，或者微信支付中页面回调时发送广播。但广播的应用场景大多都可以被`EventBus`代替。




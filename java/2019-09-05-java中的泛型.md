---
layout:     post  
title:      java中的泛型 
subtitle:   泛型
date:       2019-09-05
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

### 什么是泛型

这个概念很抽象，举个例子`List<View> list = new ArrayList<>();`	View就是list的泛型，表示这个list只能存放View类型或者View子类的对象。这么说也有些笼统，我直接把百科的介绍拿过来吧，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，可以用在类，接口，方法中。看完本篇文章你就会明白泛型到底是是什么。



### 泛型的好处

举例

~~~java
        List arrayList = new ArrayList();
        arrayList.add("aaaa");
        arrayList.add(100);

        for(int i = 0; i< arrayList.size();i++){
            String item = (String)arrayList.get(i);
        }
~~~

用了无数遍的例子，这里的List没有指定泛型，那默认的泛型就是`Object` 所以这段代码在编译时完全没问题。运行程序肯定会崩溃。这里存放的是`Object`类型，使用的时候以`String`类型使用。但是实际上添加了一个Integer类型的100，所以取出时会有类型强转错误。

修改一下代码

~~~java
        List<String> arrayList = new ArrayList();
        arrayList.add("aaaa");
        arrayList.add(100);

        for(int i = 0; i< arrayList.size();i++){
            String item = (String)arrayList.get(i);
        }
~~~

好嘛，修改完编辑器直接报错。大家应该都知道为什么报错。声明了`String`类型的`List`却存放了一个100

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6os87oxccj30b502rt8k.jpg)

这样把本来运行时候发生的错误直接提前到编译期，减少了代码出错的风险，这就泛型的好处之一



### 泛型擦除

**真泛型**

泛型存在于编译器和运行期

**伪泛型**

泛型仅仅存在于编译器

真泛型的代表有c#，关于真泛型不在本章类容里。学过java的人都知道java是伪泛型，如何验证呢？这也很简单

java可以方法重载，重载的原则是方法名一样，参数不同。

~~~java
    public void fun(List<Integer> integers) {        
    }

    public void fun(List<String> strings) {
    }
~~~

根据重载的原则，`List<Integer>!=List<String>`重载应该是成立的。然鹅并不是

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6osjg3rsoj30pc06y0sp.jpg)

这里报错了，报错信息存在里两个相同的方法。以上的代码写到c#中就不会报错。

再看一个例子

~~~java
        List<Integer> integers = new ArrayList<>();
        List<String> strings = new ArrayList<>();
        if (integers.getClass().equals(strings.getClass())) {
            System.out.println("类型相同");
        }
~~~

以上代码运行会输出日志，由此可以证明java是伪泛型，泛型在运行时会擦除。以上的	`List<Integer>` `List<String>`最后都会变成`List`



###泛型的使用

**泛型方法**

现在有这样的需求，传入两个对象，返回较大的对象。伪代码如下

~~~java
    public Comparable getMax(Comparable a, Comparable b) {
        //……比较大小
        return a;
    }

    public void fun() {       
        int a = 1;
        int b = 2;
        Comparable max = getMax(a, b);
    }
~~~

传入两个Comparable对象，比较大小后返回较大的肯定也是Comparable。其实这样很不好，在fun方法中调用时候传入了1和2，返回的却是个Comparable。很明显这里返回int类型会更好。修改一下代码

~~~java
    public <T> T getMax(T a, T b) {
        //……比较大小
        return a;
    }

    public void fun() {

        int a = 1;
        int b = 2;
        int max = getMax(a, b);
    }
~~~

在类上也要声明T `public class JavaTest<T>`

这里使用T代表泛型，getMax方法声明参数类型`<T >`  ,这样调用的时候传入的参数是什么类型就会返回什么类型



**泛型类**

~~~java
public class JavaTest<T> {
    
    private T t;

    public JavaTest(T t) {
        this.t = t;
    }

    public T getT() {
        return t;
    }
}

    //声明JavaTest对象的时候指定泛型类型，传入的t参数的类型必须要一直
    JavaTest<String> javaTest1 = new JavaTest<>("String");
    JavaTest<Integer> javaTest2 = new JavaTest<>(1);
    JavaTest<Boolean> javaTest3 = new JavaTest<>(true);
~~~





### 协变，逆变和不变

**协变**

还是先看一段代码

```java
List<TextView> textViews = new ArrayList<>();
List<Button> buttons = new ArrayList<>();
TextView textView = new Button(this);
List<TextView> textViews2 = new ArrayList<Button>();
```

声明一个`TextView`集合，一个`Button`集合，因为TextView是Button的父类，所以`TextView textView = new Button(this);`也没问题，但是`List<TextView> textViews2 = new ArrayList<Button>();`这里根据多态的特性，声明一个`TextView`集合用`Button`集合赋值应该是没问题的。然鹅...

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6pweb01y9j30kh03et8m.jpg)

这种把子类的泛型对象赋值给父类的泛型的引用叫协变，**但是**java的泛型不支持协变。因为java泛型的类型擦除，所以java对协变做了限制。但是实际使用中又会遇到这样的需求。java提供了一种解决方案，通配符 `? extends`

~~~java
        List<? extends TextView> textViews2 = new ArrayList<Button>();
~~~

?是个通配符，表示这个list是个未知的类型。extends TextView 限制了未知类型的上界限，虽然是未知类型，但是必须是TextView的子类。

你以为这样就没问题了吗 

这种写法虽然解除了协变的限制，却又带来了新的限制

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6pykujeb7j30na05dgll.jpg)



` List<? extends TextView>`的泛型是个未知泛型，只是限制了必须是TextView的子类。所以`textViews2.get(0);`得到的肯定是TextView的。当然也可以强转成TextView的子类

使用add方法，既然List<? extends TextView> 是TextView的子类的未知类型，那它可能是`List<TextView>`也可能是`List<Button>`。如果是`List<Button>`的话就不能添加TextView了。编辑器根本不知道List的实际类型也就无法确定`add(textView)`是否正确。所以干脆不让用add方法。

这又有什么用呢？？？

~~~java
    public void text() {
        List<Button> buttons = new ArrayList<>();
        fun(buttons);
    }

    public void setText(List<? extends TextView> list) {

        for (int i = 0; i < list.size(); i++) {
            list.get(i).setText("text");
        }
    }
~~~

以上的场景中setText方法接受一个TextView子类的list，然后遍历设置文字。这时你有个` List<Button>`依然也是可以调用这个方法的。如果不适用`? extends`就无法调用

由于这种限制，使用协变的泛型只能提供数据而不能修改数据。

> List<? extends TextView> 只能get() 不能 add()



**逆变**









https://blog.csdn.net/s10461/article/details/53941091



https://kaixue.io/kotlin-generics/



https://www.jianshu.com/p/2bf15c5265c5
---

layout:     post  
title:      初识Retrofit2 
subtitle:   Retrofit2
date:       2019-10-08
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

[toc]

### 基本使用

#### 创建Retrofit实例

~~~java
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("http://localhost:8081/")
        .build();
~~~



创建Retrofit实例时需要通过`Retrofit.Builder`,并调用`baseUrl`方法设置URL。

Retrofit2 的baseUlr 必须以 **/（斜线）** 结束，不然会抛出一个`IllegalArgumentException`。其实这种说法并不严谨，见

[Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)



#### 定义接口

~~~java
public interface UserService {
    @GET("user/{id}")
    Call<List<User>> getUsers(@Path("id") long id);
}
~~~

#### 创建代理对象

`UserService`是一个接口，无法直接调用其方法。所以需要通过`Retrofit`创建一个`UserService`的代理对象。

~~~java
 UserService userService = retrofit.create(UserService.class);
~~~

#### 接口调用

##### 同步请求

~~~java
        //同步请求
        try {
            Response<ResponseBody> response = users.execute();
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
~~~

##### 异步请求

~~~java
        //异步请求
        users.enqueue(new Callback<ResponseBody>() {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    System.out.println(response.body().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onFailure(Call<ResponseBody> call, Throwable t) {
                t.printStackTrace();
            }
        });
~~~

#### 获取body内容

直接调用`response.body().string()`会截断流，再次读取`response.body`就是`null`了。可以使用下面这种方式。

~~~java
public static String getResponseBody(Response response) {
        Charset UTF8 = Charset.forName("UTF-8");
        ResponseBody responseBody = response.body();
        BufferedSource source = responseBody.source();
        try {
            source.request(Long.MAX_VALUE); // Buffer the entire body.
        } catch (IOException e) {
            e.printStackTrace();
        }
        Buffer buffer = source.buffer();

        Charset charset = UTF8;
        MediaType contentType = responseBody.contentType();
        if (contentType != null) {
            try {
                charset = contentType.charset(UTF8);
            } catch (UnsupportedCharsetException e) {
                e.printStackTrace();
            }
        }
        return buffer.clone().readString(charset);
    }
~~~



### Retrofit注解详解

#### 请求方法

| 名称    | 备注                |
| ------- | ------------------- |
| GET     | get请求             |
| POST    | post请求            |
| PUT     | put请求             |
| DELETE  | delete请求          |
| PATCH   | patch请求           |
| HEAD    | head请求            |
| OPTIONS | options请求         |
| HTTP    | 可以替换以上7个请求 |

对应各自的请求方法

##### 使用HTTP请求实例

```java
public interface UserService {
      /**
     * method 表示请求的方法，区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = "GET", path = "user/{id}", hasBody = false)
    Call<List<User>> getUsers(@Path("id") long id);
}


```



#### 标记类

##### 表单请求

| 名称           | 备注                                                         |
| -------------- | ------------------------------------------------------------ |
| FormUrlEncoded | 表示请求体是From表单 Content-Type:application/x-www-form-urlencoded |
| Multipart      | 表示请求体是一个支持文件上传的From表单 Content-Type:multipart/from-data |

##### FormUrlEncoded实例

~~~java
        /**
         * FormUrlEncoded 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * Field("username") 表示将后面的 String name 中name的取值作为 username 的值
         */
        @POST("/form")
        @FormUrlEncoded
        Call<ResponseBody> testFormUrlEncoded1(@Field("username") String name, @Field("age") int age);

        /**
         * Map的key作为表单的键
         */
        @POST("/form")
        @FormUrlEncoded
        Call<ResponseBody> testFormUrlEncoded2(@FieldMap Map<String, Object> map);


        //  @FormUrlEncoded 和 @Field
        Call<ResponseBody> call1 = service.testFormUrlEncoded1("小卷子", 18);
        ResponseBodyPrinter.printResponseBody(call1);

        // @FormUrlEncoded 和 @FieldMap
        Map<String, Object> map = new HashMap<>();
        map.put("username", "小卷子");
        map.put("age", 18);
        Call<ResponseBody> call2 = service.testFormUrlEncoded2(map);
        ResponseBodyPrinter.printResponseBody(call2);

~~~

##### 标记

| 名称      | 备注                                                         |
| --------- | ------------------------------------------------------------ |
| Streaming | 表示响应体的数据用流的形式返回 如果没有使用这个注解，默认会将数据载入内存，之后读取数据也是从内存中读取。如果数据量很大就要使用这个注解 |





#### 参数类

| 名称     | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| Headers  | 添加多个请求头，用于方法外的注解                             |
| Header   | 动态添加请求头，只能用于方法参数中                           |
| Body     | 非表单请求体                                                 |
| Field    | form表单中每个字段名字以及相应数值 @Field的用法类似于@Query,不同的是@Field主要用于Post请求 |
| FieldMap | 表单域集合 用于Post请求数据,@FieldMap的用法类似于@QueryMap   |
| Part     | Post提交分块请求 (表单字段，与 PartMap 配合，适合文件上传情况) |
| PartMap  | @PartMap 表单字段，与 Part 配合，适合文件上传情况；默认接受 Map<String, RequestBody> 类型，非 RequestBody 会通过 Converter 转换 |
| Path     | 路径参数,用于替换url路径中的变量字符替换,也就是url中的{}中的部分 |
| Query    | 单个查询参数,将接口url中追加类似于"?page=1"的字符串,形成提交给服务器端的参数, 主要用于Get请求数据，用于拼接在拼接在url路径后面的查询参数，一个@Query相当于拼接一个参数 |
| QueryMap | 查询参数集合,将url中追加类似于"?page=1&count=20"的字符串,形成提交给服务器端的参数. 效果等同于多个@Query参数拼接，主要用于Get请求网络数据 |
| Url      | 使用此注解参数后,@GET后无需在添加任何内容. 方法中的@Url参数可以是全路径参数,也可以是子路径参数,但是baseurl必须要指定. |

{占位符}和**`PATH`**尽量只用在URL的path部分，url中的参数使用`Query`和`QueryMap` 代替，保证接口定义的简洁
 **注2：**`Query`、`Field`和`Part`这三者都支持**数组**和实现了`Iterable`接口的类型，如`List`，`Set`等，方便向后台传递数组。

```
Call<ResponseBody> foo(@Query("ids[]") List<Integer> ids);
//结果：ids[]=0&ids[]=1&ids[]=2
```



### Gson与Converter

默认`Retrofit`会将响应体转换为`ResponseBody`，`Converter`可以将`ResponseBody`转为为想要的类型

添加Gson依赖

~~~java
compile 'com.squareup.retrofit2:converter-gson:2.8.1'
~~~

在创建`Retrofit`对象的时候添`GsonConverterFactory`

~~~java
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("http://localhost:8081/")
                //添加GsonConverterFactory
                .addConverterFactory(GsonConverterFactory.create())
                .build();
~~~

接口中返回的`Call`泛型就可以直接定义成对象

~~~java
public interface UserService {
    @GET("user/{id}")
    Call<User> getUsers(@Path("id") long id);
}
~~~

最后请求回来的`response.body()`就是`User`











[你真的会用Retrofit2吗?Retrofit2完全教程](https://www.jianshu.com/p/308f3c54abdd/)

[Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)

[Retrofit2 完全解析 探索与okhttp之间的关系](https://blog.csdn.net/lmj623565791/article/details/51304204)
[这是一份很详细的 Retrofit 2.0 使用教程](https://blog.csdn.net/carson_ho/article/details/73732076)




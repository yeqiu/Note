---


layout:     post  
title:      初识Retrofit2 
subtitle:   Retrofit2
date:       2019-10-08
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---

[toc]

### 基本使用

基本的使用方法官网就有一个[点这里](https://square.github.io/retrofit/)，步骤大致可能分为以下几步。

1.创建接口，使用注解声明url和参数

~~~java
public interface GitHubService {
  @GET("users/{user}/repos")
  Call<List<Repo>> listRepos(@Path("user") String user);
}
~~~



2.创建Retrofit实例 

~~~java
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .build();
~~~

3.创建接口实例

~~~java
GitHubService service = retrofit.create(GitHubService.class);
~~~

4.接口调用

~~~java
Call<List<Repo>> repos = service.listRepos("octocat");
~~~

5.发起请求

~~~java
//同步请求
call.execute();
//异步请求
call.enqueue(new Callback<T>(){
        @Override
        public void onResponse (Call << T > call, Response < Result < User >> response){

    }

        @Override
        public void onFailure (Call << T > call, Throwable throwable){

    }
});
~~~



### json解析

retrofit支持添加json解析器，将返回的json自动转换成模型。支持的解析器

~~~java
Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml
JAXB: com.squareup.retrofit2:converter-jaxb
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
~~~

添加Gson解析器

```java
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
```

### baseUrl



[Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)





### 常见注解

#### @GET

用于get请求，写在方法外，一般后面会跟上请求的路由

```java
@GET("getAll")
Call<Result<User>> getAll();
```

#### @Query

设置查询参数，直接拼接在url后面

```java
@GET("getById")
Call<Result<User>> getById(@Query("id") long id);
```

请求的url：baseUrl/getById?id=真实参数

#### @QueryMap

和Query的功能一样，用于查询参数很多的时候使用map代替。

```java
@GET("getUser")
Call<Result<User>> getUser(@QueryMap Map<String, Object> params);
```

请求的url：baseUrl/getById?key1=value1&key2=value2

#### @Path

路径参数，动态替换url中的参数

```java
@GET("get/{id}")
Call<Result<User>> getWithPath(@Path("id") long id)
```

请求的url：baseUrl/get/真实参数

#### @Url

当请求的路由不确定，需要通过参数传递的时候使用

~~~java
@GET
Call<esult<User>> getDynamicUrl(@Url String url);
~~~

`@get`后面不跟路由，使用参数中的url。

#### @Headers

静态添加头部信息：包含添加单个头部、添加多个头部

通过@Headers("")注解，**内部以key:value的方式填写内容**

```java
@GET("getWithHead")
@Headers("name:test")
Call<Result<User>> getWithHead1();
```

#### @Header

动态添加单个请求头数据

```java
@GET("getWithHead")
Call<Result<User>> getWithHead2(@Header("name") String name);
```

#### @HeaderMap

动态添加多个头部信息，和@Header的功能一样。用map来代替多个参数。



#### @POST

用于post请求，写在方法外

#### @FormUrlEncoded

表单请求，和`@Field`配合使用。会将请求参数转为`application/x-www-form-urlencoded`

```java
@POST("post")
@FormUrlEncoded
Call<Result<User>> post(@Field("id") long id, @Field("name") String name);
```

#### @Field

表单请求的字段，见上例

#### @FieldMap

多个表单请求的参数

#### @Body

对应服务端的content-type 是application/json。

对应springBoot中的`@RequestBody`

```java
@POST("postBody")
Call<Result<User>> postBody(@Body User user);
```

**注意:**使用@Body注解的时候要json的解析转换。



#### @Multipart

用于上传文件

包含文件上传的请求不是普通的表单请求。

~~~java
Content-Type:multipart/form-data
~~~

不能使用@FormUrlEncoded，要修改为@Multipar

参数也不能使用@Field，要使用@Part

上传的文件类型要声明称`MultipartBody.Part`类型。

传参的时候也要麻烦一些。

~~~java
    public void postFile()throws IOException{

        File file = new File("/Users/yeqiu/Desktop/测试文档/pdf/悟空线上合同模板V20190815.pdf");
        RequestBody fileBody = RequestBody.create(MediaType.parse("file/pdf"), file);
        MultipartBody.Part file1 = MultipartBody.Part.createFormData("file", file.getName(), fileBody);
        
        Call<Result<User>> call = getApi().postFile("悟空线上合同模板V20190815", file1);
        Response<Result<User>> response = call.execute();
        Result<User> result = response.body();
        log(result);
    }
~~~



### 注解详情

#### 请求方法

| 名称    | 备注                |
| ------- | ------------------- |
| GET     | get请求             |
| POST    | post请求            |
| PUT     | put请求             |
| DELETE  | delete请求          |
| PATCH   | patch请求           |
| HEAD    | head请求            |
| OPTIONS | options请求         |
| HTTP    | 可以替换以上7个请求 |

@HTTP的示例

```java
    @HTTP(method = "GET", path = "blog/{id}", hasBody = false)
    Call<ResponseBody> getBlog(@Path("id") int id);
```

#### 表单请求

| 名称           | 备注                                                         |
| -------------- | ------------------------------------------------------------ |
| FormUrlEncoded | 表示请求体是From表单 Content-Type:application/x-www-form-urlencoded |
| Multipart      | 表示请求体是一个支持文件上传的From表单 Content-Type:multipart/from-data |

| 名称      | 备注                                                         |
| --------- | ------------------------------------------------------------ |
| Streaming | 表示响应体的数据用流的形式返回 如果没有使用这个注解，默认会将数据载入内存，之后读取数据也是从内存中读取。如果数据量很大就要使用这个注解 |

#### 参数类

| 名称     | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| Headers  | 添加多个请求头，用于方法外的注解                             |
| Header   | 动态添加请求头，只能用于方法参数中                           |
| Body     | 非表单请求体                                                 |
| Field    | form表单中每个字段名字以及相应数值 @Field的用法类似于@Query,不同的是@Field主要用于Post请求 |
| FieldMap | 表单域集合 用于Post请求数据,@FieldMap的用法类似于@QueryMap   |
| Part     | Post提交分块请求 (表单字段，与 PartMap 配合，适合文件上传情况) |
| PartMap  | @PartMap 表单字段，与 Part 配合，适合文件上传情况；默认接受 Map<String, RequestBody> 类型，非 RequestBody 会通过 Converter 转换 |
| Path     | 路径参数,用于替换url路径中的变量字符替换,也就是url中的{}中的部分 |
| Query    | 单个查询参数,将接口url中追加类似于"?page=1"的字符串,形成提交给服务器端的参数, 主要用于Get请求数据，用于拼接在拼接在url路径后面的查询参数，一个@Query相当于拼接一个参数 |
| QueryMap | 查询参数集合,将url中追加类似于"?page=1&count=20"的字符串,形成提交给服务器端的参数. 效果等同于多个@Query参数拼接，主要用于Get请求网络数据 |
| Url      | 使用此注解参数后,@GET后无需在添加任何内容. 方法中的@Url参数可以是全路径参数,也可以是子路径参数,但是baseurl必须要指定. |

{占位符}和**`PATH`**尽量只用在URL的path部分，url中的参数使用`Query`和`QueryMap` 代替，保证接口定义的简洁 \**注2：\**`Query`、`Field`和`Part`这三者都支持**数组**和实现了`Iterable`接口的类型，如`List`，`Set`等，方便向后台传递数组。

```
Call<ResponseBody> getByIds(@Query("ids[]") List<Integer> ids);
//结果：ids[0]=0&ids[1]=1&ids[]=2
```



### 拦截器

Retrofit依然使用okHttp的拦截器。

实现okhttp3.Interceptor接口创建拦截器。

例：

~~~java
public class RetrofitInterceptor implements Interceptor {


    @Override
    public Response intercept(Chain chain) throws IOException {

        Request.Builder builder = chain.request().newBuilder();

        if (true) {
            //todo 添加同一请求头
            builder.addHeader("test", "111");
        }
        Request request = builder.build();
        //打印请求体
        RetrofitLog.logRequest(request);
        Response response = chain.proceed(request);
        //打印响应体
        RetrofitLog.logResponse(response);
        
        return response;
    }

}
~~~

~~~java
package com.yeqiu.retrofit.retrofit;

import com.google.gson.JsonObject;
import okhttp3.*;
import okio.Buffer;

import java.io.IOException;
import java.net.URLDecoder;

/**
 * @project：retrofit
 * @author：小卷子
 * @date 2020/7/6
 * @describe：
 * @fix：
 */

public class RetrofitLog {

    public static void logRequest(Request request)throws IOException {

        StringBuilder log = new StringBuilder();

        log.append("----> 请求开始 ")
                .append(" url = ")
                .append(request.url())
                .append(" ")
                .append("method = ")
                .append(request.method())
                .append(" ");

        RequestBody requestBody = request.body();
        if (requestBody != null) {
            Buffer buffer = new Buffer();
            requestBody.writeTo(buffer);
            String requestBodyString;

            try {
                requestBodyString = URLDecoder.decode(buffer.readUtf8(), "UTF-8");
            }catch (Exception e){
                requestBodyString = buffer.readUtf8();
            }


            log.append("requestBody = ")
                    .append(requestBodyString)
                    .append(" ");
        }

        Headers headers = request.headers();
        if (headers != null && headers.size() > 0) {
            log.append("head = ");
            JsonObject headJson = new JsonObject();
            for (int i = 0; i < headers.size(); i++) {
                headJson.addProperty(headers.name(i), headers.value(i));
            }
            log.append(headJson.toString());
        }


        System.out.println(log.toString());


    }

    public static void logResponse(Response response) throws  IOException {


        ResponseBody responseBody = response.peekBody(1024 * 1024);
        StringBuilder log = new StringBuilder();
        try {
            log.append("<---- 请求结束 ")
                    .append(" url = ")
                    .append(response.request().url())
                    .append(" ")
                    .append("status = ")
                    .append(response.code())
                    .append(" ")
                    .append("responseBody = ")
                    .append(responseBody.string());
        }catch (Exception e){
        }
        
        System.out.println(log.toString());
    }

}

~~~





### 其他

1.当@GET或@POST注解的url为全路径时（可能和baseUrl不是一个域），会直接使用注解的url的 域。

2.以上介绍的注解可以混合使用













[你真的会用Retrofit2吗?Retrofit2完全教程](https://www.jianshu.com/p/308f3c54abdd/)

[Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)

[Retrofit2 完全解析 探索与okhttp之间的关系](https://blog.csdn.net/lmj623565791/article/details/51304204)
[这是一份很详细的 Retrofit 2.0 使用教程](https://blog.csdn.net/carson_ho/article/details/73732076)




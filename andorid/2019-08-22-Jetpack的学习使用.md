layout:     post  
title:      Jetpack的学习使用 
subtitle:   Jetpack
date:       2019-08-22
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:

- 标签

[TOC]

## Data Binding

Livedata，ViewModel和Livecycles等一系列Android Jetpack组件非常适用于实现MVVM。

[MVC、MVP、MVVM，我到底该怎么选？](https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&mid=2649492883&idx=1&sn=2c206702fe1dd357ed65052bb9080488&chksm=8eec866cb99b0f7aabe917b584eee71dea51a57b22d54fac96cfbd420a0f53340350ae978321&scene=38#wechat_redirect)
[浅析前端开发中的 MVC/MVP/MVVM 模式](https://juejin.im/post/593021272f301e0058273468)
[MVC，MVP，MVPVM（一）实践之路](https://www.jianshu.com/p/8ea5868d11f1)















## Lifecycles

看名字就知道是关于生命周期的处理，Lifecycle是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。

先上代码

~~~java
class AppLifecycleObserver : LifecycleObserver {

    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    fun onLifecycleChanged(owner: LifecycleOwner, event: Lifecycle.Event) {
        LogUtils.log("onLifecycleChanged  "+ owner.javaClass.simpleName)
        LogUtils.log("onLifecycleChanged  "+ event.name)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    fun onCreate(owner: LifecycleOwner) {
        LogUtils.log("onCreate "+ owner.javaClass.simpleName)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun onStart(owner: LifecycleOwner) {
        LogUtils.log("onStart  "+owner.javaClass.simpleName)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    fun onResume(owner: LifecycleOwner) {
        LogUtils.log("onResume  "+ owner.javaClass.simpleName)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    fun onPause(owner: LifecycleOwner) {
        LogUtils.log("onPause  "+owner.javaClass.simpleName)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop(owner: LifecycleOwner) {
        LogUtils.log("onStop  "+owner.javaClass.simpleName)
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    fun onDestroy(owner: LifecycleOwner) {
        LogUtils.log("onDestroy  "+owner.javaClass.simpleName)
    }
}
~~~

在Activity/Fragment容器中添加Observer

~~~kotlin
class LifecycleActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_lifecycle)

        lifecycle.addObserver(AppLifecycleObserver())

    }  
}
~~~

这是当Activity的生命周期发生变化，AppLifecycleObserver也会执行响应的方法

每次生命周期变化后都会在调用Lifecycle.Event.ON_ANY






## Navigation

`Navigation`是一个可简化Android导航的库和插件，更确切的来说，`Navigation`是用来管理`Fragment`的切换，并且可以通过可视化的方式，看见App的交互流程。

使用Navigation的步骤

**准备工作**

添加依赖

~~~java
    implementation "androidx.navigation:navigation-fragment-ktx:$rootProject.navigationVersion"
    implementation "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"
~~~



先创建好Activity和Fragment和对应的布局文件

**1.在Activity 布局中声明 NavGraphFragment**

~~~java
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    <fragment
            android:id="@+id/fragment_nav"
            android:name="androidx.navigation.fragment.NavHostFragment"
            app:defaultNavHost="true"
            app:navGraph="@navigation/nav_graph_demo"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

</androidx.constraintlayout.widget.ConstraintLayout>
~~~

这里有几个属性：

`android:name="androidx.navigation.fragment.NavHostFragment"`

必须设置name属性，name属性的值必须是NavHostFragment（前面到取决你是否使用Android）

` app:defaultNavHost="true"`

defaultNavHost:NavGraphFragment是否会拦截系统back键，系统back键默认会关闭Activity

如果使用了toolbar，还要重写Activity的onSupportNavigateUp

~~~java
override fun onSupportNavigateUp()
        = findNavController(R.id.fragment_nav).navigateUp()
~~~

` app:navGraph="@navigation/nav_graph_main"`

navGraph：使用对应的文件，这里是nav_graph_demo（这个文件需要在res/navigatio）

**2.创建Navigation文件**

在res/navigatio文件中创建一个Navigatio resource file

然后添加对应的fragment

新版Studio可以直接使用按钮添加

![](http://ww4.sinaimg.cn/large/006y8mN6ly1g68l93h7kcj30mt0diwek.jpg)

自动生成的代码

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<navigation
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/nav_graph_demo"
        app:startDestination="@id/navFragment1">

    <fragment
            android:id="@+id/navFragment1"
            android:name="com.yeqiu.jetpack_demo.navdemo.NavFragment1"
            android:label="NavFragment1"/>

    <fragment
            android:id="@+id/mainPage2Fragment"
            android:name="com.yeqiu.jetpack_demo.MainPage2Fragment"
            android:label="MainPage2Fragment"/>

    <fragment
            android:id="@+id/navFragment3"
            android:name="com.yeqiu.jetpack_demo.navdemo.NavFragment3"
            android:label="NavFragment3"/>

</navigation>
~~~

这里有一个很重要的属性`startDestination` 可以理解成主页，这里默认显示navFragment1

在对应的fragment添加layout属性即可在设计页面预览

~~~xml
 tools:layout="@layout/fragment_nav_1"
~~~



声明导航行为 action

设计页面可以直接点击拖动来设置跳转的activty

拖动完成后可以在xml页面稍作修改

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<navigation
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/nav_graph_demo"
        app:startDestination="@id/mainPage1Fragment1">

    <fragment
            android:id="@+id/mainPage1Fragment1"
            android:name="com.yeqiu.jetpack_demo.MainPage1Fragment"
            tools:layout="@layout/fragment_nav_1"
            android:label="MainPage1Fragment">

        <action android:id="@+id/action_to_2"
                app:destination="@id/navFragment2"/>

    </fragment>

    <fragment
            android:id="@+id/navFragment2"
            android:name="com.yeqiu.jetpack_demo.navdemo.NavFragment2"
            tools:layout="@layout/fragment_nav_2"
            android:label="NavFragment2">

        <action android:id="@+id/action_to_3"
                app:destination="@id/navFragment3"/>

    </fragment>

    <fragment
            android:id="@+id/navFragment3"
            android:name="com.yeqiu.jetpack_demo.navdemo.NavFragment3"
            tools:layout="@layout/fragment_nav_3"
            android:label="NavFragment3">

        <action android:id="@+id/action_to_1"
                app:destination="@id/mainPage1Fragment1"/>

    </fragment>

</navigation>
~~~

每个destination属性即目的地，代表要跳转的页面。id作为action的唯一表示，可以在代码中找到并指向

**3.代码中跳转**

activity中无需再配置其他代码会直接显示默认的destination

~~~java
class NavFragment1 : Fragment() {

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View {
        return inflater.inflate(R.layout.fragment_nav_1, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        next1.setOnClickListener{
            Navigation.findNavController(it).navigate(R.id.action_to_2)
        }

    } 
}
~~~

对应的点击事件中直接使用` Navigation.findNavController(view).navigate(actionId)`,对应执行Navigatio资源文件中的跳转



**其他属性**

1.app:popUpTo -> 在fragment的action中指定，代替destination。可以直接返回刚才已经打开的fragment（从1 -> 2 -> ，如果 3直接popUpTo 1，2会直接被销毁） 

在代码中使用返回上一页 

~~~java
            Navigation.findNavController(it).popBackStack()
~~~



2.Navigation 还支持 转场动画 

~~~mxl
  <action android:id="@+id/action_to_2"
                app:enterAnim="@anim/slide_right_in"
                app:exitAnim="@anim/slide_left_out"
                app:popEnterAnim="@anim/slide_left_in"
                app:popExitAnim="@anim/slide_right_out"
                app:destination="@id/navFragment2"/>
~~~

3.代码直接返回返回上一个fragment

~~~java
btn.setOnClickListener {
      Navigation.findNavController(it).navigateUp()
}
~~~



**ViewPager样式：BottomNavigationView**

直接上代码

1.创建Activity，布局中添加 `NavHostFragment`和`BottomNavigationView`

~~~xml
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".navigation.ViewPagerNavigationActivity">

    <fragment
        android:id="@+id/viewPagerNavHostFragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:defaultNavHost="true"
        app:layout_constraintBottom_toTopOf="@+id/viewPagerNavigationView"
        app:layout_constraintTop_toTopOf="parent"
        app:navGraph="@navigation/viewpager_navigation" />

    <com.google.android.material.bottomnavigation.BottomNavigationView
        android:id="@+id/viewPagerNavigationView"
        android:layout_width="match_parent"
        android:layout_height="50dp"
        android:background="#fff"
        app:itemIconTint="@color/colorAccent"
        app:itemTextColor="@color/colorPrimary"
        app:menu="@menu/view_pager_nav_menu"
        app:layout_constraintBottom_toBottomOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
~~~

`BottomNavigationView`中`menu`的属性指定一个xml文件，就是底部的按钮

view_pager_nav_menu

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/viewPagerNavigationFragment1"
        android:icon="@mipmap/ic_launcher"
        android:title="首页" />

    <item
        android:id="@+id/viewPagerNavigationFragment2"
        android:icon="@mipmap/ic_launcher"
        android:title="发现" />

    <item
        android:id="@+id/viewPagerNavigationFragment3"
        android:icon="@mipmap/ic_launcher"
        android:title="我的" />

</menu>
~~~



2.创建导航文件，跟之前一样。在res/navigatio文件中创建一个Navigatio resource file。可以在图形化页面添加fragment。不用再添加action

viewpager_navigation

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/viewpager_navigation"
    app:startDestination="@id/viewPagerNavigationFragment1">

    <fragment
        android:id="@+id/viewPagerNavigationFragment1"
      android:name="com.yeqiu.jetpack_demo.navigation.fragment.ViewPagerNavigationFragment1"
        android:label="ViewPagerNavigationFragment1"
        tools:layout="@layout/fragment_simple_navigation_1" />

    <fragment
        android:id="@+id/viewPagerNavigationFragment2"
      android:name="com.yeqiu.jetpack_demo.navigation.fragment.ViewPagerNavigationFragment2"
        android:label="ViewPagerNavigationFragment2"
        tools:layout="@layout/fragment_simple_navigation_2" />

    <fragment
        android:id="@+id/viewPagerNavigationFragment3"
      android:name="com.yeqiu.jetpack_demo.navigation.fragment.ViewPagerNavigationFragment3"
        android:label="ViewPagerNavigationFragment3"
        tools:layout="@layout/fragment_simple_navigation_3" />


</navigation>
~~~



3.创建Fragment和对应的布局文件，代码中无需做任何处理。



4.Activity中添加导航处理。

~~~java
class ViewPagerNavigationActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_viewpager_navigation)

        setNavBottom()
    }
    
    private fun setNavBottom() {

        val navHostFragment =
            supportFragmentManager.findFragmentById(R.id.viewPagerNavHostFragment) as NavHostFragment
        val navController = navHostFragment.navController
        //底部的导航交给navController处理
        viewPagerNavigationView.setupWithNavController(navController)

    }
}
~~~

运行应该就可以实现类似微信主页的效果

注意：导航文件中的fragment的id一定要和menu文件中的item id对应。



**DeepLink**

Deeplink，就是你在其他app上点击一个链接之后，可以直接链接到app内部的某个页面，而不是app正常打开时显示的首页。

上代码

1.创建Acitivty和Fragment 和使用BottomNavigationView一样，navigation文件中不添加action，添加deepLink标签

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/deep_link_navigation"
    app:startDestination="@id/deepLinkFragment">
    <fragment
        android:id="@+id/deepLinkFragment"
        android:name="com.yeqiu.jetpack_demo.navigation.fragment.DeepLinkFragment"
        tools:layout="@layout/fragment_simple_navigation_1"
        android:label="DeepLinkFragment" >
        <deepLink
            android:id="@+id/deepLink"
            app:uri="www.jetpackdemo.com/{data}" />
    </fragment>
</navigation>
~~~

`app:uri="www.jetpackdemo.com/{data}"` /后面可以接受参数 data是key，通过 Bundle 进行传递

2.清单文件中注册的activity添加

~~~xml
        <activity android:name=".navigation.DeepLinkActivity">
            <nav-graph android:value="@navigation/deep_link_navigation" />
        </activity>
~~~

应用中通过浏览器打开选择自己的app

简单的使用到这里结束了，Navigation底层是通过replace来实现页面切换的，如何替换成hide/show可以看下这片文章

[Navigation 之 Fragment 切换](https://jiangjiwei.site/post/navigation-zhi-fragment-qie-huan/)

其他资料

[Android官方架构组件Navigation：大巧不工的Fragment管理框架](https://blog.csdn.net/mq2553299/article/details/80445952)

[一个App真的只需要一个Activity](https://mp.weixin.qq.com/s/quuwF_Iz39ofYbtLbIn04w)





## ViewModel

代表着 **数据驱动视图** 的思想，在实际开发中通过这些数据的状态，来维护UI的自动更新，这就是 **数据驱动视图（观察者模式）**每当数据源发生变化，view层能自动进行更新。在开发过程中可以大幅减少view和model的相互调用。

 ViewModel 是出于管理和存储 UI 相关数据的目的，通过对 Android 组件生命周期感知的方式而设计出来的一个组件，并且允许在设备的配置发生变更（如屏幕旋转）时继续保持。

这样的话最直接的好处就是开发者不再需要关心 Activity / Fragment 的相关状态数据持久化（saveInstanceStatus）的问题了，能够专注于产品业务的开发，避免缓存恢复数据这种重复模板化操作。

ViewModel用户管理和储存和View相关的数据，可以再页面生命周期发生变化的时候保持继续（如屏幕旋转）



ViewModel 如何工作的示意图

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g6hum5ib6gj30hq0i50tk.jpg)











https://mp.weixin.qq.com/s/tTP8y6OrYNE9GIhR9DbuJQ

https://juejin.im/post/5d5a3cd9f265da03c23ed40a

https://www.jianshu.com/p/721cdcdf11b2





## LiveData



## Paging



## WorkManger



## Room





